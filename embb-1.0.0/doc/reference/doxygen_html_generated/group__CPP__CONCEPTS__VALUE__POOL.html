<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Embedded Multicore Building Blocks V1.0.0: Value Pool Concept</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="DoxygenHTMLStyle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Embedded Multicore Building Blocks V1.0.0
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>API</span></a></li>
      <li><a href="annotated.html"><span>Type&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">Value Pool Concept<div class="ingroups"><a class="el" href="group__CPP__CONCEPT.html">C++ Concepts</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Concept for thread-safe value pools.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembb_1_1containers_1_1LockFreeTreeValuePool.html">embb::containers::LockFreeTreeValuePool&lt; Type, Undefined, PoolAllocator, TreeAllocator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock-free value pool using binary tree construction.  <a href="classembb_1_1containers_1_1LockFreeTreeValuePool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classembb_1_1containers_1_1WaitFreeArrayValuePool.html">embb::containers::WaitFreeArrayValuePool&lt; Type, Undefined, Allocator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait-free value pool using array construction.  <a href="classembb_1_1containers_1_1WaitFreeArrayValuePool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Concept for thread-safe value pools. </p>
<dl class="section user"><dt>Description</dt><dd>A value pool is a multi-set of elements, where each element has a unique, continuous (starting with 0) index. The elements cannot be modified and are given at construction time by providing first/last iterators.</dd></dl>
<dl class="section user"><dt></dt><dd>A value pool provides two primary operations: <code>Allocate</code> and <code>Free</code>. <code>Allocate</code> allocates an element/index "pair" (index via return, element via reference parameter) from the pool, and <code>Free</code> returns an element/index pair to the pool. To guarantee linearizability, <code>element</code> is not allowed to be modified between <code>Allocate</code> and <code>Free</code>. It is only allowed to free elements that have previously been allocated. The <code>Allocate</code> function does not guarantee an order on which indices are allocated. The count of elements that can be allocated with <code>Allocate</code> might be smaller than the count of elements, the pool is initialized with. This might be because of implementation details and respective concurrency effects: for example, if indices are managed within a queue, one has to protect queue elements from concurrency effects (reuse and access). As long as a thread potentially accesses a node (and with that an index), the respective index cannot not be given out to the user, even if being logically not part of the pool anymore. However, the user might want to guarantee a certain amount of indices to the user. Therefore, the static <code>GetMinimumElementCountForGuaranteedCapacity</code> method is used. The user passes the count of indices to this method that shall be guaranteed by the pool. The method returns the count on indices, the pool has to be initialized with in order to guarantee this count on indices.</dd></dl>
<dl class="section user"><dt>Requirements</dt><dd><ul>
<li>Let <code>Pool</code> be the pool class</li>
<li>Let <code>Type</code> be the element type of the pool. Atomic operations must be possible on <code>Type</code>.</li>
<li>Let <code>b</code>, d be objects of type <code>Type</code> </li>
<li>Let <code>i</code>, j be forward iterators supporting <code>std::distance</code>.</li>
<li>Let <code>c</code> be an object of type <code>Type&amp;</code> </li>
<li>Let <code>e</code> be a value of type <code>int</code> </li>
<li>Let <code>f</code> be a value of type <code>int</code> </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Valid Expressions</dt><dd></dd></dl>
<table class="doxtable">
<tr>
<th>Expression </th><th>Return type </th><th>Description  </th></tr>
<tr>
<td><div class="fragment"><div class="line">Pool&lt;Type, b&gt;(i, j) </div></div><!-- fragment -->  </td><td>Nothing </td><td>Constructs a value pool holding elements of type <code>Type</code>, where <code>b</code> is the bottom element. The bottom element cannot be stored in the pool, it is exclusively used to mark empty cells. The pool initially contains <code>std::distance(i, j)</code> elements which are copied during construction from the range <code></code>[i, j]. A concrete class satisfying the value pool concept might provide additional template parameters for specifying allocators.   </td></tr>
<tr>
<td><div class="fragment"><div class="line">Allocate(c) </div></div><!-- fragment --> </td><td><code>int</code>  </td><td>Allocates an element/index "pair" from the pool. Returns -1, if no element is available, i.e., the pool is empty. Otherwise, returns the index of the element in the pool. The value of the pool element is written into parameter reference <code>c</code>.   </td></tr>
<tr>
<td><div class="fragment"><div class="line">Free(d, e) </div></div><!-- fragment --> </td><td><code>void</code>  </td><td>Returns an element <code>d</code> to the pool, where <code>e</code> is its index. The values of <code>d</code> and <code>e</code> have to match the values of the previous call to <code>Allocate</code>. For each allocated element, <code>Free</code> must be called exactly once.  </td></tr>
<tr>
<td><div class="fragment"><div class="line">GetMinimumElementCountForGuaranteedCapacity(f)</div></div><!-- fragment --> </td><td><code>void</code>  </td><td>Static method, returns the count of indices, the user has to initialize the pool with in order to guarantee a count of <code>f</code> elements (irrespective of concurrency effects).   </td></tr>
</table>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jun 27 2017 04:05:15 for Embedded Multicore Building Blocks V1.0.0 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
