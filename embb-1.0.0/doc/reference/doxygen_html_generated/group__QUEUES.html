<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Embedded Multicore Building Blocks V1.0.0: Queues</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="DoxygenHTMLStyle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Embedded Multicore Building Blocks V1.0.0
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>API</span></a></li>
      <li><a href="annotated.html"><span>Type&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Queues<div class="ingroups"><a class="el" href="group__C.html">C Components</a> &raquo; <a class="el" href="group__C__MTAPI.html">MTAPI</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Queues for controlling the scheduling policy of tasks.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmtapi__queue__attributes__struct.html">mtapi_queue_attributes_struct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue attributes.  <a href="structmtapi__queue__attributes__struct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmtapi__queue__hndl__struct.html">mtapi_queue_hndl_struct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue handle.  <a href="structmtapi__queue__hndl__struct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga59d8efd8cf04d9f1f57246fb559f4ac0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmtapi__queue__hndl__struct.html#ad5d123ffa7c7bb4c86214dd4e3c63407">mtapi_queue_hndl_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QUEUES.html#ga59d8efd8cf04d9f1f57246fb559f4ac0">mtapi_queue_create</a> (const mtapi_queue_id_t queue_id, const <a class="el" href="structmtapi__job__hndl__struct.html#aa569fed9c9d6d695c607a1d6d47bf9a8">mtapi_job_hndl_t</a> job, const <a class="el" href="structmtapi__queue__attributes__struct.html#adf70e98d01234bc1e5cacf6d3d9c1f51">mtapi_queue_attributes_t</a> *attributes, mtapi_status_t *status)</td></tr>
<tr class="memdesc:ga59d8efd8cf04d9f1f57246fb559f4ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creates a software queue object and associates it with the specified job.  <a href="#ga59d8efd8cf04d9f1f57246fb559f4ac0">More...</a><br /></td></tr>
<tr class="separator:ga59d8efd8cf04d9f1f57246fb559f4ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46de2cffdc59b1458994a5607fd8c241"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QUEUES.html#ga46de2cffdc59b1458994a5607fd8c241">mtapi_queue_set_attribute</a> (const <a class="el" href="structmtapi__queue__hndl__struct.html#ad5d123ffa7c7bb4c86214dd4e3c63407">mtapi_queue_hndl_t</a> queue, const mtapi_uint_t attribute_num, const void *attribute, const mtapi_size_t attribute_size, mtapi_status_t *status)</td></tr>
<tr class="memdesc:ga46de2cffdc59b1458994a5607fd8c241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the attribute value that corresponds to the given <code>attribute_num</code> for the specified queue.  <a href="#ga46de2cffdc59b1458994a5607fd8c241">More...</a><br /></td></tr>
<tr class="separator:ga46de2cffdc59b1458994a5607fd8c241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18c816af187f853c4ae1a12da9441541"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QUEUES.html#ga18c816af187f853c4ae1a12da9441541">mtapi_queue_get_attribute</a> (const <a class="el" href="structmtapi__queue__hndl__struct.html#ad5d123ffa7c7bb4c86214dd4e3c63407">mtapi_queue_hndl_t</a> queue, const mtapi_uint_t attribute_num, void *attribute, const mtapi_size_t attribute_size, mtapi_status_t *status)</td></tr>
<tr class="memdesc:ga18c816af187f853c4ae1a12da9441541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the attribute value that corresponds to the given <code>attribute_num</code> for the specified queue.  <a href="#ga18c816af187f853c4ae1a12da9441541">More...</a><br /></td></tr>
<tr class="separator:ga18c816af187f853c4ae1a12da9441541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga018463a8b9e6bbdfd3f223420460f518"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmtapi__queue__hndl__struct.html#ad5d123ffa7c7bb4c86214dd4e3c63407">mtapi_queue_hndl_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QUEUES.html#ga018463a8b9e6bbdfd3f223420460f518">mtapi_queue_get</a> (const mtapi_queue_id_t queue_id, const mtapi_domain_t domain_id, mtapi_status_t *status)</td></tr>
<tr class="memdesc:ga018463a8b9e6bbdfd3f223420460f518"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts a domain-wide <code>queue_id</code> into a node-local queue handle.  <a href="#ga018463a8b9e6bbdfd3f223420460f518">More...</a><br /></td></tr>
<tr class="separator:ga018463a8b9e6bbdfd3f223420460f518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0acb377a964e5a35492f30eea8885eb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QUEUES.html#ga0acb377a964e5a35492f30eea8885eb2">mtapi_queue_delete</a> (const <a class="el" href="structmtapi__queue__hndl__struct.html#ad5d123ffa7c7bb4c86214dd4e3c63407">mtapi_queue_hndl_t</a> queue, const mtapi_timeout_t timeout, mtapi_status_t *status)</td></tr>
<tr class="memdesc:ga0acb377a964e5a35492f30eea8885eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function deletes the specified software queue.  <a href="#ga0acb377a964e5a35492f30eea8885eb2">More...</a><br /></td></tr>
<tr class="separator:ga0acb377a964e5a35492f30eea8885eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb2f6a1d59946ad29baf3535b0307564"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QUEUES.html#gabb2f6a1d59946ad29baf3535b0307564">mtapi_queue_disable</a> (const <a class="el" href="structmtapi__queue__hndl__struct.html#ad5d123ffa7c7bb4c86214dd4e3c63407">mtapi_queue_hndl_t</a> queue, const mtapi_timeout_t timeout, mtapi_status_t *status)</td></tr>
<tr class="memdesc:gabb2f6a1d59946ad29baf3535b0307564"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function disables the specified queue in such a way that it can be resumed later.  <a href="#gabb2f6a1d59946ad29baf3535b0307564">More...</a><br /></td></tr>
<tr class="separator:gabb2f6a1d59946ad29baf3535b0307564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0a202478b3ce6dbea1e60e863c054b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QUEUES.html#gaa0a202478b3ce6dbea1e60e863c054b5">mtapi_queue_enable</a> (const <a class="el" href="structmtapi__queue__hndl__struct.html#ad5d123ffa7c7bb4c86214dd4e3c63407">mtapi_queue_hndl_t</a> queue, mtapi_status_t *status)</td></tr>
<tr class="memdesc:gaa0a202478b3ce6dbea1e60e863c054b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function may be called from any node with a valid queue handle to re-enable a queue previously disabled with <a class="el" href="group__QUEUES.html#gabb2f6a1d59946ad29baf3535b0307564" title="This function disables the specified queue in such a way that it can be resumed later. ">mtapi_queue_disable()</a>.  <a href="#gaa0a202478b3ce6dbea1e60e863c054b5">More...</a><br /></td></tr>
<tr class="separator:gaa0a202478b3ce6dbea1e60e863c054b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Queues for controlling the scheduling policy of tasks. </p>
<p>The default scheduling policy for queues is ordered task execution. Tasks that have to be executed sequentially are enqueued into the same queue. In this case every queue is associated with exactly one action. Tasks started via different queues can be executed in parallel. This is needed for packet processing applications, for example: each stream is processed by one queue. This ensures sequential processing of packets belonging to the same stream. Different streams are processed in parallel.</p>
<p>Queues were made explicit in MTAPI. This allows mapping of queues onto hardware queues, if available. One MTAPI queue is associated with one action, or for purposes of load balancing, with actions implementing the same job on different nodes. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga59d8efd8cf04d9f1f57246fb559f4ac0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmtapi__queue__hndl__struct.html#ad5d123ffa7c7bb4c86214dd4e3c63407">mtapi_queue_hndl_t</a> mtapi_queue_create </td>
          <td>(</td>
          <td class="paramtype">const mtapi_queue_id_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmtapi__job__hndl__struct.html#aa569fed9c9d6d695c607a1d6d47bf9a8">mtapi_job_hndl_t</a>&#160;</td>
          <td class="paramname"><em>job</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmtapi__queue__attributes__struct.html#adf70e98d01234bc1e5cacf6d3d9c1f51">mtapi_queue_attributes_t</a> *&#160;</td>
          <td class="paramname"><em>attributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mtapi_status_t *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function creates a software queue object and associates it with the specified job. </p>
<p>A job is associated with one or more actions that provide the executable implementation of the job. Hardware queues are considered to be pre-existent and do not need to be created.</p>
<p><code>queue_id</code> is an identifier of implementation-defined type that must be supplied by the application. If <code>queue_id</code> is set to <code>MTAPI_QUEUE_ID_NONE</code>, the queue will be accessible only on the node on which it was created by using the returned queue handle. Otherwise the application may supply a <code>queue_id</code> by which the queue can be referenced domain-wide using <a class="el" href="group__QUEUES.html#ga018463a8b9e6bbdfd3f223420460f518" title="This function converts a domain-wide queue_id into a node-local queue handle. ">mtapi_queue_get()</a> to convert the id into a handle. The minimum and maximum values for <code>queue_id</code> may be derived from <code>MTAPI_MIN_USER_QUEUE_ID</code> and <code>MTAPI_MAX_USER_QUEUE_ID</code>.</p>
<p>job is a handle to a job obtained by a previous call to <a class="el" href="group__JOBS.html#ga98478d5d43e829490880b5eba7363a8d" title="Given a job_id, this function returns the MTAPI handle for referencing the actions implementing the j...">mtapi_job_get()</a>. If <code>attributes</code> is <code>MTAPI_NULL</code>, the queue will be created with default attribute values. Otherwise <code>attributes</code> must point to a queue attributes object previously prepared using <a class="el" href="structmtapi__queue__attributes__struct.html#a720e881a25feb3485a7faeae5f4ba683" title="This function initializes a queue attributes object. ">mtapi_queueattr_init()</a> and <a class="el" href="structmtapi__queue__attributes__struct.html#af48b67bb9a1d493e5f0cb068c39581c4" title="This function sets queue attribute values in a queue attributes object. ">mtapi_queueattr_set()</a>.</p>
<p>There is an implementation-defined maximum number of queues permitted.</p>
<p>If more than one action is associated with the job, the runtime system chooses dynamically which action is used for execution (for load balancing purposes).</p>
<p>On success, a queue handle is returned and <code>*status</code> is set to <code>MTAPI_SUCCESS</code>. On error, <code>*status</code> is set to the appropriate error defined below. In the case where the queue already exists, <code>*status</code> will be set to <code>MTAPI_QUEUE_EXISTS</code> and the handle returned will not be a valid handle. </p><table class="doxtable">
<tr>
<th>Error code </th><th>Description  </th></tr>
<tr>
<td><code>MTAPI_ERR_QUEUE_INVALID</code> </td><td>The <code>queue_id</code> is not a valid queue id. </td></tr>
<tr>
<td><code>MTAPI_ERR_QUEUE_EXISTS</code> </td><td>This queue is already created. </td></tr>
<tr>
<td><code>MTAPI_ERR_QUEUE_LIMIT</code> </td><td>Exceeded maximum number of queues allowed. </td></tr>
<tr>
<td><code>MTAPI_ERR_NODE_NOTINIT</code> </td><td>The calling node is not initialized. </td></tr>
<tr>
<td><code>MTAPI_ERR_PARAMETER</code> </td><td>Invalid attributes parameter. </td></tr>
<tr>
<td><code>MTAPI_ERR_JOB_INVALID</code> </td><td>The associated job is not valid. </td></tr>
</table>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__QUEUES.html#ga018463a8b9e6bbdfd3f223420460f518" title="This function converts a domain-wide queue_id into a node-local queue handle. ">mtapi_queue_get()</a>, <a class="el" href="group__JOBS.html#ga98478d5d43e829490880b5eba7363a8d" title="Given a job_id, this function returns the MTAPI handle for referencing the actions implementing the j...">mtapi_job_get()</a>, <a class="el" href="structmtapi__queue__attributes__struct.html#a720e881a25feb3485a7faeae5f4ba683" title="This function initializes a queue attributes object. ">mtapi_queueattr_init()</a>, <a class="el" href="structmtapi__queue__attributes__struct.html#af48b67bb9a1d493e5f0cb068c39581c4" title="This function sets queue attribute values in a queue attributes object. ">mtapi_queueattr_set()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to newly created queue, invalid handle on error </dd></dl>
<dl class="section user"><dt>Concurrency</dt><dd>Thread-safe </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue_id</td><td>Queue id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">job</td><td>Job handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attributes</td><td>Pointer to attributes </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">status</td><td>Pointer to error code, may be <code>MTAPI_NULL</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga46de2cffdc59b1458994a5607fd8c241"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mtapi_queue_set_attribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmtapi__queue__hndl__struct.html#ad5d123ffa7c7bb4c86214dd4e3c63407">mtapi_queue_hndl_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mtapi_uint_t&#160;</td>
          <td class="paramname"><em>attribute_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mtapi_size_t&#160;</td>
          <td class="paramname"><em>attribute_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mtapi_status_t *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the attribute value that corresponds to the given <code>attribute_num</code> for the specified queue. </p>
<p>See <a class="el" href="structmtapi__queue__attributes__struct.html#af48b67bb9a1d493e5f0cb068c39581c4" title="This function sets queue attribute values in a queue attributes object. ">mtapi_queueattr_set()</a> for a list of predefined attribute numbers and the sizes of the attribute values. The application must set <code>attribute_size</code> to the exact size in bytes of the attribute value. Additional attributes may be defined by the implementation.</p>
<p>On success, <code>*status</code> is set to <code>MTAPI_SUCCESS</code>. On error, <code>*status</code> is set to the appropriate error defined below and the attribute value is undefined. </p><table class="doxtable">
<tr>
<th>Error code </th><th>Description  </th></tr>
<tr>
<td><code>MTAPI_ERR_PARAMETER</code> </td><td>Invalid attribute parameter. </td></tr>
<tr>
<td><code>MTAPI_ERR_QUEUE_INVALID</code> </td><td>Argument is not a valid queue handle. </td></tr>
<tr>
<td><code>MTAPI_ERR_ATTR_NUM</code> </td><td>Unknown attribute number. </td></tr>
<tr>
<td><code>MTAPI_ERR_ATTR_SIZE</code> </td><td>Incorrect attribute size. </td></tr>
<tr>
<td><code>MTAPI_ERR_NODE_NOTINIT</code> </td><td>The calling node is not initialized. </td></tr>
</table>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structmtapi__queue__attributes__struct.html#af48b67bb9a1d493e5f0cb068c39581c4" title="This function sets queue attribute values in a queue attributes object. ">mtapi_queueattr_set()</a></dd></dl>
<dl class="section user"><dt>Concurrency</dt><dd>Not thread-safe </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>Queue handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attribute_num</td><td>Attribute id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attribute</td><td>Pointer to attribute value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attribute_size</td><td>Size of attribute value. may be 0, attribute is interpreted as value in that case </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">status</td><td>Pointer to error code, may be <code>MTAPI_NULL</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga18c816af187f853c4ae1a12da9441541"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mtapi_queue_get_attribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmtapi__queue__hndl__struct.html#ad5d123ffa7c7bb4c86214dd4e3c63407">mtapi_queue_hndl_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mtapi_uint_t&#160;</td>
          <td class="paramname"><em>attribute_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mtapi_size_t&#160;</td>
          <td class="paramname"><em>attribute_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mtapi_status_t *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the attribute value that corresponds to the given <code>attribute_num</code> for the specified queue. </p>
<p><code>attribute</code> must point to a location in memory sufficiently large to hold the returned attribute value. See <a class="el" href="structmtapi__queue__attributes__struct.html#af48b67bb9a1d493e5f0cb068c39581c4" title="This function sets queue attribute values in a queue attributes object. ">mtapi_queueattr_set()</a> for a list of predefined attribute numbers and the sizes of the attribute values. The application must set <code>attribute_size</code> to the exact size in bytes of the attribute value. Additional attributes may be defined by the implementation.</p>
<p>On success, <code>*status</code> is set to <code>MTAPI_SUCCESS</code> and the attribute value is returned in <code>*attribute</code>. On error, <code>*status</code> is set to the appropriate error defined below and the <code>*attribute</code> value is undefined. If this function is called on a queue that no longer exists, an <code>MTAPI_ERR_QUEUE_INVALID</code> error will be returned. </p><table class="doxtable">
<tr>
<th>Error code </th><th>Description  </th></tr>
<tr>
<td><code>MTAPI_ERR_PARAMETER</code> </td><td>Invalid attribute parameter. </td></tr>
<tr>
<td><code>MTAPI_ERR_QUEUE_INVALID</code> </td><td>Argument is not a valid queue handle. </td></tr>
<tr>
<td><code>MTAPI_ERR_ATTR_NUM</code> </td><td>Unknown attribute number. </td></tr>
<tr>
<td><code>MTAPI_ERR_ATTR_SIZE</code> </td><td>Incorrect attribute size. </td></tr>
<tr>
<td><code>MTAPI_ERR_NODE_NOTINIT</code> </td><td>The calling node is not initialized. </td></tr>
</table>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structmtapi__queue__attributes__struct.html#af48b67bb9a1d493e5f0cb068c39581c4" title="This function sets queue attribute values in a queue attributes object. ">mtapi_queueattr_set()</a></dd></dl>
<dl class="section user"><dt>Concurrency</dt><dd>Thread-safe and wait-free </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>Queue handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attribute_num</td><td>Attribute id </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">attribute</td><td>Pointer to attribute value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attribute_size</td><td>Size of attribute value </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">status</td><td>Pointer to error code, may be <code>MTAPI_NULL</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga018463a8b9e6bbdfd3f223420460f518"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmtapi__queue__hndl__struct.html#ad5d123ffa7c7bb4c86214dd4e3c63407">mtapi_queue_hndl_t</a> mtapi_queue_get </td>
          <td>(</td>
          <td class="paramtype">const mtapi_queue_id_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mtapi_domain_t&#160;</td>
          <td class="paramname"><em>domain_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mtapi_status_t *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function converts a domain-wide <code>queue_id</code> into a node-local queue handle. </p>
<p><code>queue_id</code> must match the <code>queue_id</code> that was associated with a software queue that was created with <a class="el" href="group__QUEUES.html#ga59d8efd8cf04d9f1f57246fb559f4ac0" title="This function creates a software queue object and associates it with the specified job...">mtapi_queue_create()</a>, or it must be a valid predefined queue identifier known a priori to the runtime and application (e.g., to reference a hardware queue. The minimum and maximum values for <code>queue_id</code> may be derived from <code>MTAPI_MIN_USER_QUEUE_ID</code> and <code>MTAPI_MAX_USER_QUEUE_ID</code>.</p>
<p>On success, the queue handle is returned and <code>*status</code> is set to <code>MTAPI_SUCCESS</code>. On error, <code>*status</code> is set to the appropriate error defined below. If this function is called on a queue that no longer exists, an <code>MTAPI_ERR_QUEUE_INVALID</code> error will be returned. </p><table class="doxtable">
<tr>
<th>Error code </th><th>Description  </th></tr>
<tr>
<td><code>MTAPI_ERR_QUEUE_INVALID</code>  </td><td>The <code>queue_id</code> parameter does not refer to a valid queue or it is set to <code>MTAPI_QUEUE_ID_ANY</code>.  </td></tr>
<tr>
<td><code>MTAPI_ERR_NODE_NOTINIT</code>  </td><td>The node/domain is not initialized.  </td></tr>
<tr>
<td><code>MTAPI_ERR_DOMAIN_NOTSHARED</code>  </td><td>This resource cannot be shared by this domain.  </td></tr>
</table>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__QUEUES.html#ga59d8efd8cf04d9f1f57246fb559f4ac0" title="This function creates a software queue object and associates it with the specified job...">mtapi_queue_create()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to preexisting queue with given <code>queue_id</code>, invalid handle on error </dd></dl>
<dl class="section user"><dt>Concurrency</dt><dd>Thread-safe </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue_id</td><td>Queue id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">domain_id</td><td>Domain id </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">status</td><td>Pointer to error code, may be <code>MTAPI_NULL</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0acb377a964e5a35492f30eea8885eb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mtapi_queue_delete </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmtapi__queue__hndl__struct.html#ad5d123ffa7c7bb4c86214dd4e3c63407">mtapi_queue_hndl_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mtapi_timeout_t&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mtapi_status_t *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function deletes the specified software queue. </p>
<p>Hardware queues are perpetual and cannot be deleted.</p>
<p><code>queue</code> must be a valid handle to an existing queue.</p>
<p><code>timeout</code> determines how long the function should wait for tasks already started via that queue to finish. The underlying type of <code>mtapi_timeout_t</code> is implementation-defined. If <code>timeout</code> is a constant 0 or the symbolic constant <code>MTAPI_NOWAIT</code>, this function deletes the queue and returns immediately. If <code>timeout</code> is set to <code>MTAPI_INFINITE</code> the function may block infinitely. Other values for <code>timeout</code> and the units of measure are implementation defined.</p>
<p>This function can be called from any node that has a valid queue handle. Tasks previously enqueued in a queue that has been deleted may still be executed depending on their internal state:</p><ul>
<li>If <a class="el" href="group__QUEUES.html#ga0acb377a964e5a35492f30eea8885eb2" title="This function deletes the specified software queue. ">mtapi_queue_delete()</a> is called on a queue that is currently executing an action, the task state of the corresponding task will be set to <code>MTAPI_TASK_CANCELLED</code> and execution will continue. To accomplish this, the action function must poll the task state with <a class="el" href="group__ACTION__FUNCTIONS.html#ga394161ccebdbc041b9f63355b79d42f5" title="An action function may call this function to obtain the state of the task that is associated with the...">mtapi_context_taskstate_get()</a>. A call to <a class="el" href="group__TASKS.html#ga6e0b06a9470b39700b33e425b7b345c4" title="This function waits for the completion of the specified task. ">mtapi_task_wait()</a> on the task executing this code will return the status set by <a class="el" href="group__ACTION__FUNCTIONS.html#ga4620187dc8dfe9cd25ada6689c61006e" title="This function can be called from an action function to set the status that can be obtained by a subse...">mtapi_context_status_set()</a>, or <code>MTAPI_SUCCESS</code> if not explicitly set.</li>
<li>Tasks that are enqueued and waiting for execution by the MTAPI runtime environment when <a class="el" href="group__QUEUES.html#ga0acb377a964e5a35492f30eea8885eb2" title="This function deletes the specified software queue. ">mtapi_queue_delete()</a> is called will not be executed any more. A call to <a class="el" href="group__TASKS.html#ga6e0b06a9470b39700b33e425b7b345c4" title="This function waits for the completion of the specified task. ">mtapi_task_wait()</a> will return the status <code>MTAPI_ERR_QUEUE_DELETED</code>.</li>
<li>Tasks that are enqueued after deletion of the queue will return a status of <code>MTAPI_ERR_QUEUE_INVALID</code>.</li>
</ul>
<p>If this function is called on a queue that no longer exists, an <code>MTAPI_ERR_QUEUE_INVALID</code> status will be returned. A call to <a class="el" href="group__QUEUES.html#ga018463a8b9e6bbdfd3f223420460f518" title="This function converts a domain-wide queue_id into a node-local queue handle. ">mtapi_queue_get()</a> on a deleted queue will return <code>MTAPI_ERR_QUEUE_INVALID</code> as well, as long as no new queue has been created for the same queue ID.</p>
<p>On success, <code>*status</code> is set to <code>MTAPI_SUCCESS</code>. On error, <code>*status</code> is set to the appropriate error defined below. </p><table class="doxtable">
<tr>
<th>Error code </th><th>Description  </th></tr>
<tr>
<td><code>MTAPI_ERR_QUEUE_INVALID</code> </td><td>Argument is not a valid queue handle. </td></tr>
<tr>
<td><code>MTAPI_ERR_NODE_NOTINIT</code> </td><td>The calling node is not initialized. </td></tr>
<tr>
<td><code>MTAPI_TIMEOUT</code> </td><td>Timeout was reached. </td></tr>
</table>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ACTION__FUNCTIONS.html#ga394161ccebdbc041b9f63355b79d42f5" title="An action function may call this function to obtain the state of the task that is associated with the...">mtapi_context_taskstate_get()</a>, <a class="el" href="group__ACTION__FUNCTIONS.html#ga4620187dc8dfe9cd25ada6689c61006e" title="This function can be called from an action function to set the status that can be obtained by a subse...">mtapi_context_status_set()</a>, <a class="el" href="group__TASKS.html#ga6e0b06a9470b39700b33e425b7b345c4" title="This function waits for the completion of the specified task. ">mtapi_task_wait()</a>, <a class="el" href="group__QUEUES.html#ga018463a8b9e6bbdfd3f223420460f518" title="This function converts a domain-wide queue_id into a node-local queue handle. ">mtapi_queue_get()</a></dd></dl>
<dl class="section user"><dt>Concurrency</dt><dd>Thread-safe </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>Queue handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Timeout duration in milliseconds </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">status</td><td>Pointer to error code, may be <code>MTAPI_NULL</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabb2f6a1d59946ad29baf3535b0307564"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mtapi_queue_disable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmtapi__queue__hndl__struct.html#ad5d123ffa7c7bb4c86214dd4e3c63407">mtapi_queue_hndl_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mtapi_timeout_t&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mtapi_status_t *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function disables the specified queue in such a way that it can be resumed later. </p>
<p>This is needed to perform certain maintenance tasks. It can be called by any node that has a valid queue handle.</p>
<p><code>timeout</code> determines how long the function should wait for tasks already started via that queue to finish. The underlying type of <code>mtapi_timeout_t</code> is implementation-defined. If <code>timeout</code> is a constant 0 or the symbolic constant <code>MTAPI_NOWAIT</code>, this function deletes the queue and returns immediately. If <code>timeout</code> is set to <code>MTAPI_INFINITE</code> the function may block infinitely. Other values for <code>timeout</code> and the units of measure are implementation defined.</p>
<p>Tasks previously enqueued in a queue that has been disabled may still be executed depending on their internal state:</p><ul>
<li>If <a class="el" href="group__QUEUES.html#gabb2f6a1d59946ad29baf3535b0307564" title="This function disables the specified queue in such a way that it can be resumed later. ">mtapi_queue_disable()</a> is called on a queue that is currently executing an action, the task state of the corresponding task will be set to <code>MTAPI_TASK_CANCELLED</code> and execution will continue. To accomplish this, the action function must poll the task state by calling <a class="el" href="group__ACTION__FUNCTIONS.html#ga394161ccebdbc041b9f63355b79d42f5" title="An action function may call this function to obtain the state of the task that is associated with the...">mtapi_context_taskstate_get()</a>. A call to <a class="el" href="group__TASKS.html#ga6e0b06a9470b39700b33e425b7b345c4" title="This function waits for the completion of the specified task. ">mtapi_task_wait()</a> on the task executing this code will return the status set by <a class="el" href="group__ACTION__FUNCTIONS.html#ga4620187dc8dfe9cd25ada6689c61006e" title="This function can be called from an action function to set the status that can be obtained by a subse...">mtapi_context_status_set()</a>, or <code>MTAPI_SUCCESS</code> if not explicitly set.</li>
<li>Tasks that are enqueued and waiting for execution by the MTAPI runtime environment when <a class="el" href="group__QUEUES.html#gabb2f6a1d59946ad29baf3535b0307564" title="This function disables the specified queue in such a way that it can be resumed later. ">mtapi_queue_disable()</a> is called will not be executed anymore. They will be held in anticipation the queue is enabled again if the <code>MTAPI_QUEUE_RETAIN</code> attribute is set to <code>MTAPI_TRUE</code>. A call to <a class="el" href="group__TASKS.html#ga6e0b06a9470b39700b33e425b7b345c4" title="This function waits for the completion of the specified task. ">mtapi_task_wait()</a> will return the status <code>MTAPI_ERR_QUEUE_DISABLED</code>.</li>
<li>Tasks that are enqueued after the queue had been disabled will return <code>MTAPI_ERR_QUEUE_DISABLED</code> if the <code>MTAPI_QUEUE_RETAIN</code> attribute is set to <code>MTAPI_FALSE</code>.</li>
</ul>
<p>On success, <code>*status</code> is set to <code>MTAPI_SUCCESS</code>. On error, <code>*status</code> is set to the appropriate error defined below. </p><table class="doxtable">
<tr>
<th>Error code </th><th>Description  </th></tr>
<tr>
<td><code>MTAPI_ERR_QUEUE_INVALID</code> </td><td>Argument is not a valid queue handle. </td></tr>
<tr>
<td><code>MTAPI_ERR_NODE_NOTINIT</code> </td><td>The calling node is not initialized. </td></tr>
<tr>
<td><code>MTAPI_TIMEOUT</code> </td><td>Timeout was reached. </td></tr>
</table>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ACTION__FUNCTIONS.html#ga394161ccebdbc041b9f63355b79d42f5" title="An action function may call this function to obtain the state of the task that is associated with the...">mtapi_context_taskstate_get()</a>, <a class="el" href="group__ACTION__FUNCTIONS.html#ga4620187dc8dfe9cd25ada6689c61006e" title="This function can be called from an action function to set the status that can be obtained by a subse...">mtapi_context_status_set()</a>, <a class="el" href="group__TASKS.html#ga6e0b06a9470b39700b33e425b7b345c4" title="This function waits for the completion of the specified task. ">mtapi_task_wait()</a></dd></dl>
<dl class="section user"><dt>Concurrency</dt><dd>Thread-safe </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>Queue handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Timeout duration in milliseconds </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">status</td><td>Pointer to error code, may be <code>MTAPI_NULL</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa0a202478b3ce6dbea1e60e863c054b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mtapi_queue_enable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmtapi__queue__hndl__struct.html#ad5d123ffa7c7bb4c86214dd4e3c63407">mtapi_queue_hndl_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mtapi_status_t *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function may be called from any node with a valid queue handle to re-enable a queue previously disabled with <a class="el" href="group__QUEUES.html#gabb2f6a1d59946ad29baf3535b0307564" title="This function disables the specified queue in such a way that it can be resumed later. ">mtapi_queue_disable()</a>. </p>
<p>On success, <code>*status</code> is set to <code>MTAPI_SUCCESS</code>. On error, <code>*status</code> is set to the appropriate error defined below. </p><table class="doxtable">
<tr>
<th>Error code </th><th>Description  </th></tr>
<tr>
<td><code>MTAPI_ERR_QUEUE_INVALID</code> </td><td>Argument is not a valid queue handle. </td></tr>
<tr>
<td><code>MTAPI_ERR_NODE_NOTINIT</code> </td><td>The calling node is not initialized. </td></tr>
</table>
<dl class="section user"><dt>Concurrency</dt><dd>Thread-safe </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>Queue handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">status</td><td>Pointer to error code, may be <code>MTAPI_NULL</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jun 27 2017 04:05:15 for Embedded Multicore Building Blocks V1.0.0 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
