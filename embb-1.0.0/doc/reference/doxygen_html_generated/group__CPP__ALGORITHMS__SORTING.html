<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Embedded Multicore Building Blocks V1.0.0: Sorting</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="DoxygenHTMLStyle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Embedded Multicore Building Blocks V1.0.0
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>API</span></a></li>
      <li><a href="annotated.html"><span>Type&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Sorting<div class="ingroups"><a class="el" href="group__CPP.html">C++ Components</a> &raquo; <a class="el" href="group__CPP__ALGORITHMS.html">Algorithms</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Parallel merge sort and quick sort algorithms.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga736788ec95b07ba9394685a14aa60b98"><td class="memTemplParams" colspan="2">template&lt;typename RAI , typename ComparisonFunction &gt; </td></tr>
<tr class="memitem:ga736788ec95b07ba9394685a14aa60b98"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CPP__ALGORITHMS__SORTING.html#ga736788ec95b07ba9394685a14aa60b98">embb::algorithms::MergeSortAllocate</a> (RAI first, RAI last, ComparisonFunction comparison=std::less&lt; typename std::iterator_traits&lt; RAI &gt;::value_type &gt;(), const <a class="el" href="classembb_1_1mtapi_1_1ExecutionPolicy.html">embb::mtapi::ExecutionPolicy</a> &amp;policy=<a class="el" href="classembb_1_1mtapi_1_1ExecutionPolicy.html">embb::mtapi::ExecutionPolicy</a>(), size_t block_size=0)</td></tr>
<tr class="memdesc:ga736788ec95b07ba9394685a14aa60b98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts a range of elements using a parallel merge sort algorithm with implicit allocation of dynamic memory.  <a href="group__CPP__ALGORITHMS__SORTING.html#ga736788ec95b07ba9394685a14aa60b98">More...</a><br /></td></tr>
<tr class="separator:ga736788ec95b07ba9394685a14aa60b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35febf71a28477ab2a2682cad7f4123b"><td class="memTemplParams" colspan="2">template&lt;typename RAI , typename RAITemp , typename ComparisonFunction &gt; </td></tr>
<tr class="memitem:ga35febf71a28477ab2a2682cad7f4123b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CPP__ALGORITHMS__SORTING.html#ga35febf71a28477ab2a2682cad7f4123b">embb::algorithms::MergeSort</a> (RAI first, RAI last, RAITemp temporary_first, ComparisonFunction comparison=std::less&lt; typename std::iterator_traits&lt; RAI &gt;::value_type &gt;(), const <a class="el" href="classembb_1_1mtapi_1_1ExecutionPolicy.html">embb::mtapi::ExecutionPolicy</a> &amp;policy=<a class="el" href="classembb_1_1mtapi_1_1ExecutionPolicy.html">embb::mtapi::ExecutionPolicy</a>(), size_t block_size=0)</td></tr>
<tr class="memdesc:ga35febf71a28477ab2a2682cad7f4123b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts a range of elements using a parallel merge sort algorithm without implicit allocation of dynamic memory.  <a href="group__CPP__ALGORITHMS__SORTING.html#ga35febf71a28477ab2a2682cad7f4123b">More...</a><br /></td></tr>
<tr class="separator:ga35febf71a28477ab2a2682cad7f4123b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56719c870bc2dfc90c69a5b95d5a2375"><td class="memTemplParams" colspan="2">template&lt;typename RAI , typename ComparisonFunction &gt; </td></tr>
<tr class="memitem:ga56719c870bc2dfc90c69a5b95d5a2375"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CPP__ALGORITHMS__SORTING.html#ga56719c870bc2dfc90c69a5b95d5a2375">embb::algorithms::QuickSort</a> (RAI first, RAI last, ComparisonFunction comparison=std::less&lt; typename std::iterator_traits&lt; RAI &gt;::value_type &gt;(), const <a class="el" href="classembb_1_1mtapi_1_1ExecutionPolicy.html">embb::mtapi::ExecutionPolicy</a> &amp;policy=<a class="el" href="classembb_1_1mtapi_1_1ExecutionPolicy.html">embb::mtapi::ExecutionPolicy</a>(), size_t block_size=0)</td></tr>
<tr class="memdesc:ga56719c870bc2dfc90c69a5b95d5a2375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts a range of elements using a parallel quick sort algorithm.  <a href="group__CPP__ALGORITHMS__SORTING.html#ga56719c870bc2dfc90c69a5b95d5a2375">More...</a><br /></td></tr>
<tr class="separator:ga56719c870bc2dfc90c69a5b95d5a2375"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Parallel merge sort and quick sort algorithms. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga736788ec95b07ba9394685a14aa60b98"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RAI , typename ComparisonFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void embb::algorithms::MergeSortAllocate </td>
          <td>(</td>
          <td class="paramtype">RAI&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RAI&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ComparisonFunction&#160;</td>
          <td class="paramname"><em>comparison</em> = <code>std::less&lt;&#160;typename&#160;std::iterator_traits&lt;&#160;RAI&#160;&gt;::value_type&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classembb_1_1mtapi_1_1ExecutionPolicy.html">embb::mtapi::ExecutionPolicy</a> &amp;&#160;</td>
          <td class="paramname"><em>policy</em> = <code><a class="el" href="classembb_1_1mtapi_1_1ExecutionPolicy.html">embb::mtapi::ExecutionPolicy</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>block_size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts a range of elements using a parallel merge sort algorithm with implicit allocation of dynamic memory. </p>
<p>The range consists of the elements from <code>first</code> to <code>last</code>, excluding the last element. Since the algorithm does not sort in-place, it requires additional memory which is implicitly allocated by the function.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classembb_1_1base_1_1ErrorException.html" title="Indicates a general error. ">embb::base::ErrorException</a></td><td>if not enough MTAPI tasks can be created to satisfy the requirements of the algorithm. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Dynamic memory allocation</dt><dd>Array with <code>last-first</code> elements of type <code>std::iterator_traits&lt;RAI&gt;::value_type</code>. </dd></dl>
<dl class="section user"><dt>Concurrency</dt><dd>Thread-safe if the elements in the range <code>[first,last)</code> are not modified by another thread while the algorithm is executed. </dd></dl>
<dl class="section user"><dt>Note</dt><dd>No guarantee is given on the execution order of the comparison operations.<br />
 For nested algorithms, the task limit may be exceeded. In that case, increase the task limit of the MTAPI node. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classembb_1_1mtapi_1_1ExecutionPolicy.html" title="Describes the execution policy of a parallel algorithm. ">embb::mtapi::ExecutionPolicy</a>, <a class="el" href="group__CPP__ALGORITHMS__SORTING.html#ga35febf71a28477ab2a2682cad7f4123b" title="Sorts a range of elements using a parallel merge sort algorithm without implicit allocation of dynami...">MergeSort()</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RAI</td><td>Random access iterator </td></tr>
    <tr><td class="paramname">ComparisonFunction</td><td>Binary predicate with both arguments of type <code>std::iterator_traits&lt;RAI&gt;::value_type</code> or an <a class="el" href="classembb_1_1mtapi_1_1Job.html" title="Represents a collection of Actions. ">embb::mtapi::Job</a> associated with an action function accepting a struct containing two members of type <code>std::iterator_traits&lt;RAI&gt;::value_type</code> as its argument buffer and a struct containing one bool member as its result buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Random access iterator pointing to the first element of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Random access iterator pointing to the last plus one element of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comparison</td><td>Binary predicate used to establish the sorting order. An element <code>a</code> appears before an element <code>b</code> in the sorted range if <code>comparison(a, b) == true</code>. The default value uses the less-than relation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">policy</td><td><a class="el" href="classembb_1_1mtapi_1_1ExecutionPolicy.html" title="Describes the execution policy of a parallel algorithm. ">embb::mtapi::ExecutionPolicy</a> for the merge sort algorithm </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block_size</td><td>Lower bound for partitioning the range of elements into blocks that are sorted in parallel. Partitioning of a block stops if its size is less than or equal to <code>block_size</code>. The default value 0 means that the minimum block size is determined automatically depending on the number of elements in the range divided by the number of available cores. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga35febf71a28477ab2a2682cad7f4123b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RAI , typename RAITemp , typename ComparisonFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void embb::algorithms::MergeSort </td>
          <td>(</td>
          <td class="paramtype">RAI&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RAI&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RAITemp&#160;</td>
          <td class="paramname"><em>temporary_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ComparisonFunction&#160;</td>
          <td class="paramname"><em>comparison</em> = <code>std::less&lt;&#160;typename&#160;std::iterator_traits&lt;&#160;RAI&#160;&gt;::value_type&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classembb_1_1mtapi_1_1ExecutionPolicy.html">embb::mtapi::ExecutionPolicy</a> &amp;&#160;</td>
          <td class="paramname"><em>policy</em> = <code><a class="el" href="classembb_1_1mtapi_1_1ExecutionPolicy.html">embb::mtapi::ExecutionPolicy</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>block_size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts a range of elements using a parallel merge sort algorithm without implicit allocation of dynamic memory. </p>
<p>The range consists of the elements from <code>first</code> to <code>last</code>, excluding the last element. Since the algorithm does not sort in-place, it requires additional memory which must be provided by the user. The range pointed to by <code>temporary_first</code> must have the same number of elements as the range to be sorted, and the elements of both ranges must have the same type.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classembb_1_1base_1_1ErrorException.html" title="Indicates a general error. ">embb::base::ErrorException</a></td><td>if not enough MTAPI tasks can be created to satisfy the requirements of the algorithm. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Concurrency</dt><dd>Thread-safe if the elements in the ranges <code>[first,last)</code> and <code>[temporary_first,temporary_first+(last-first)</code> are not modified by another thread while the algorithm is executed. </dd></dl>
<dl class="section user"><dt>Note</dt><dd>No guarantee is given on the execution order of the comparison operations.<br />
 For nested algorithms, the task limit may be exceeded. In that case, increase the task limit of the MTAPI node. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classembb_1_1mtapi_1_1ExecutionPolicy.html" title="Describes the execution policy of a parallel algorithm. ">embb::mtapi::ExecutionPolicy</a>, <a class="el" href="group__CPP__ALGORITHMS__SORTING.html#ga736788ec95b07ba9394685a14aa60b98" title="Sorts a range of elements using a parallel merge sort algorithm with implicit allocation of dynamic m...">MergeSortAllocate()</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RAI</td><td>Random access iterator </td></tr>
    <tr><td class="paramname">RAITemp</td><td>Random access iterator for temporary memory. Has to have the same value type as RAI. </td></tr>
    <tr><td class="paramname">ComparisonFunction</td><td>Binary predicate with both arguments of type <code>std::iterator_traits&lt;RAI&gt;::value_type</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Random access iterator pointing to the first element of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Random access iterator to last plus one element to be sorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">temporary_first</td><td>Random access iterator pointing to the last plus one element of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comparison</td><td>Binary predicate used to establish the sorting order. An element <code>a</code> appears before an element <code>b</code> in the sorted range if <code>comparison(a, b) == true</code>. The default value uses the less-than relation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">policy</td><td><a class="el" href="classembb_1_1mtapi_1_1ExecutionPolicy.html" title="Describes the execution policy of a parallel algorithm. ">embb::mtapi::ExecutionPolicy</a> for the merge sort algorithm </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block_size</td><td>Lower bound for partitioning the range of elements into blocks that are sorted in parallel. Partitioning of a block stops if its size is less than or equal to <code>block_size</code>. The default value 0 means that the minimum block size is determined automatically depending on the number of elements in the range divided by the number of available cores. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga56719c870bc2dfc90c69a5b95d5a2375"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RAI , typename ComparisonFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void embb::algorithms::QuickSort </td>
          <td>(</td>
          <td class="paramtype">RAI&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RAI&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ComparisonFunction&#160;</td>
          <td class="paramname"><em>comparison</em> = <code>std::less&lt;&#160;typename&#160;std::iterator_traits&lt;&#160;RAI&#160;&gt;::value_type&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classembb_1_1mtapi_1_1ExecutionPolicy.html">embb::mtapi::ExecutionPolicy</a> &amp;&#160;</td>
          <td class="paramname"><em>policy</em> = <code><a class="el" href="classembb_1_1mtapi_1_1ExecutionPolicy.html">embb::mtapi::ExecutionPolicy</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>block_size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts a range of elements using a parallel quick sort algorithm. </p>
<p>The range consists of the elements from <code>first</code> to <code>last</code>, excluding the last element. The algorithm sorts in-place and requires no additional memory. It has, however, a worst-case time complexity of <code>O((last-first)<sup>2</sup>)</code>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classembb_1_1base_1_1ErrorException.html" title="Indicates a general error. ">embb::base::ErrorException</a></td><td>if not enough MTAPI tasks can be created to satisfy the requirements of the algorithm. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Concurrency</dt><dd>Thread-safe if the elements in the range <code>[first,last)</code> are not modified by another thread while the algorithm is executed. </dd></dl>
<dl class="section user"><dt>Note</dt><dd>No guarantee is given on the execution order of the comparison operations.<br />
 For nested algorithms, the task limit may be exceeded. In that case, increase the task limit of the MTAPI node. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classembb_1_1mtapi_1_1ExecutionPolicy.html" title="Describes the execution policy of a parallel algorithm. ">embb::mtapi::ExecutionPolicy</a>, <a class="el" href="group__CPP__ALGORITHMS__SORTING.html#ga35febf71a28477ab2a2682cad7f4123b" title="Sorts a range of elements using a parallel merge sort algorithm without implicit allocation of dynami...">MergeSort()</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RAI</td><td>Random access iterator </td></tr>
    <tr><td class="paramname">ComparisonFunction</td><td>Binary predicate with both arguments of type <code>std::iterator_traits&lt;RAI&gt;::value_type</code> or an <a class="el" href="classembb_1_1mtapi_1_1Job.html" title="Represents a collection of Actions. ">embb::mtapi::Job</a> associated with an action function accepting a struct containing two members of type <code>std::iterator_traits&lt;RAI&gt;::value_type</code> as its argument buffer and a struct containing one bool member as its result buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Random access iterator pointing to the first element of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Random access iterator pointing to the last plus one element of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comparison</td><td>Binary predicate used to establish the sorting order. An element <code>a</code> appears before an element <code>b</code> in the sorted range if <code>comparison(a, b) == true</code>. The default value uses the less-than relation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">policy</td><td><a class="el" href="classembb_1_1mtapi_1_1ExecutionPolicy.html" title="Describes the execution policy of a parallel algorithm. ">embb::mtapi::ExecutionPolicy</a> for the quick sort algorithm </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block_size</td><td>Lower bound for partitioning the range of elements into blocks that are sorted in parallel. Partitioning of a block stops if its size is less than or equal to <code>block_size</code>. The default value 0 means that the minimum block size is determined automatically depending on the number of elements in the range divided by the number of available cores. Note that quick sort does not guarantee a partitioning into evenly sized blocks, as the partitions depend on the values to be sorted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jun 27 2017 04:05:15 for Embedded Multicore Building Blocks V1.0.0 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
