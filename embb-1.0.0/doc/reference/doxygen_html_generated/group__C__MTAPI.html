<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Embedded Multicore Building Blocks V1.0.0: MTAPI</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="DoxygenHTMLStyle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Embedded Multicore Building Blocks V1.0.0
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>API</span></a></li>
      <li><a href="annotated.html"><span>Type&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a>  </div>
  <div class="headertitle">
<div class="title">MTAPI<div class="ingroups"><a class="el" href="group__C.html">C Components</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Multicore Task Management API (MTAPI&reg;).  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__RUNTIME__INIT__SHUTDOWN"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RUNTIME__INIT__SHUTDOWN.html">General</a></td></tr>
<tr class="memdesc:group__RUNTIME__INIT__SHUTDOWN"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization, introspection, and finalization functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__ACTIONS"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ACTIONS.html">Actions</a></td></tr>
<tr class="memdesc:group__ACTIONS"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hardware or software implementations of jobs. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__ACTION__FUNCTIONS"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ACTION__FUNCTIONS.html">Action Functions</a></td></tr>
<tr class="memdesc:group__ACTION__FUNCTIONS"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executable software functions that implement actions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__CORE__AFFINITY__MASKS"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CORE__AFFINITY__MASKS.html">Core Affinities</a></td></tr>
<tr class="memdesc:group__CORE__AFFINITY__MASKS"><td class="mdescLeft">&#160;</td><td class="mdescRight">Affinities for executing action functions on subsets of cores. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__QUEUES"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__QUEUES.html">Queues</a></td></tr>
<tr class="memdesc:group__QUEUES"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queues for controlling the scheduling policy of tasks. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__JOBS"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__JOBS.html">Jobs</a></td></tr>
<tr class="memdesc:group__JOBS"><td class="mdescLeft">&#160;</td><td class="mdescRight">Jobs implementing one or more actions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__TASKS"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TASKS.html">Tasks</a></td></tr>
<tr class="memdesc:group__TASKS"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tasks representing pieces of work "in flight" (similar to a thread handles). <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__TASK__GROUPS"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TASK__GROUPS.html">Task Groups</a></td></tr>
<tr class="memdesc:group__TASK__GROUPS"><td class="mdescLeft">&#160;</td><td class="mdescRight">Facilities for synchronizing on groups of tasks. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__C__MTAPI__EXT"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__C__MTAPI__EXT.html">MTAPI Extensions</a></td></tr>
<tr class="memdesc:group__C__MTAPI__EXT"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides extensions to the standard MTAPI API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Multicore Task Management API (MTAPI&reg;). </p>
<p>MTAPI is an API standardized by the <a href="http://www.multicore-association.org">Multicore Association</a> for leveraging task parallelism on a wide range of embedded devices containing symmetric or asymmetric multicore processors. A description of the basic terms and concepts is given below. More information can be found on the website of the <a href="http://www.multicore-association.org/workgroup/mtapi.php">Multicore Task Management Working Group</a>.</p>
<h2>Definitions</h2>
<table class="doxtable">
<tr>
<td>Action </td><td>An action is the hardware or software implementation of a job. An action implemented in software consists of the implementation of an action function with a predefined signature. Software actions are registered with the MTAPI runtime and associated with a job. While executing, an action is also associated with a task and task context. Hardware implementations of actions must be known a priori in the MTAPI runtime implementation. There is no standardized way of registering hardware actions because they are highly hardware-dependent. Hardware and software actions are referenced by handles or indirectly through job IDs and job handles.  </td></tr>
<tr>
<td>Action Function </td><td>The executable function of an action, invoked by the MTAPI runtime when a task is started.  </td></tr>
<tr>
<td>Affinity </td><td>Defines which cores can execute a given action function.  </td></tr>
<tr>
<td>Blocking </td><td>A blocking function does not return until the function completes successfully or returns with an error.  </td></tr>
<tr>
<td>Core </td><td>A core is an undividable processing element. Two cores can share resources such as memory or ALUs for hyperthreaded cores. The core notion is necessary for core affinity, but is implementation-specific.  </td></tr>
<tr>
<td>Domain </td><td>An implementation of MTAPI includes one or more domains, each with one or more nodes. The concept of domains is consistent in all Multicore Association APIs. A domain is comparable to a subnet in a network or a namespace for unique names and IDs. Domains are supported by a runtime.  </td></tr>
<tr>
<td>Handle </td><td>An abstract reference to an object on the same node or to an object managed by another node. A handle is valid only on the node on which it was requested and generated. A handle is opaque, that is, its underlying representation is implementation-defined. Handles can be copied, assigned, and passed as arguments, but the application should make no other assumptions about the type, representation, or contents of a handle.  </td></tr>
<tr>
<td>Job </td><td>A job provides a way to reference one or more actions. Jobs are abstractions of the processing implemented in hardware or software by actions. Multiple actions can implement the same job based on different hardware resources (for instance a job can be implemented by one action on a DSP and by another action on a general purpose core, or a job can be implemented by both hardware and software actions). Each job is represented by a domain-wide job ID, or by a job handle local to a node.  </td></tr>
<tr>
<td>MCA </td><td>The Multicore Association.  </td></tr>
<tr>
<td>MTAPI </td><td>Multicore Task Management API, defined by The Multicore Association.   </td></tr>
<tr>
<td>Node </td><td>A node represents an independent unit of execution that maps to a process, thread, thread pool, instance of an operating system, hardware accelerator, processor core, a cluster of processor cores, or other abstract processing entity with an independent program counter. Each node can belong to only one domain. The concept of nodes is consistent in all Multicore Associations APIs. Code executed on an MTAPI node shares memory (data) with any other code executed on the same node.  </td></tr>
<tr>
<td>Queue </td><td>A software or hardware entity in which tasks are enqueued in a given order. The queue can ensure in-order execution of tasks. Furthermore, queues might implement other scheduling policies that can be configured by setting queue attributes.  </td></tr>
<tr>
<td>Reference </td><td>A reference exists when an object or abstract entity has knowledge or access to another object, without regard to the specific means of the implementation.  </td></tr>
<tr>
<td>Resource </td><td>A processing core or chip, hardware accelerator, memory region, or I/O.  </td></tr>
<tr>
<td>Remote Memory </td><td>Memory that cannot be accessed using standard load and store operations. For example, host memory is remote to a GPU core.  </td></tr>
<tr>
<td>Runtime System </td><td>An MTAPI runtime system (or "runtime") is the underlying implementation of MTAPI. The core of the runtime system supports task scheduling and communication with other nodes. Each MTAPI has an MTAPI runtime system.  </td></tr>
<tr>
<td>SMP </td><td>SMP is short for symmetric multiprocessing, in which two or more identical processing cores are connected to a shared main memory and are controlled by a single OS instance.  </td></tr>
<tr>
<td>Task </td><td>A task is the invocation of an action. A task is associated with a job object, which is associated with one or more actions. A task may optionally be associated with a task group. A task has attributes and an internal state. A task begins its lifetime with a call to <a class="el" href="group__TASKS.html#gae1f5e0c8001e50f64222b0f2fb39e237" title="This function schedules a task for execution. ">mtapi_task_start()</a> or <a class="el" href="group__TASKS.html#ga0765ea20297d85d72cfd16db671e1fbd" title="This function schedules a task for execution using a queue. ">mtapi_task_enqueue()</a>. A task is referenced by a handle of type mtapi_task_hndl_t. After a task has started, it is possible to wait for task completion from other parts of the program. Every task can run exactly once, i.e., the task cannot be started a second time. (Note that in other contexts, the term "task" has a different meaning. Some real-time operating systems use "task" for operating system threads, for example.)  </td></tr>
<tr>
<td>Task Context </td><td>Information about the task, accessible by the corresponding action function; useful for action code reflection.  </td></tr>
</table>
<h2>The MTAPI Feature Set</h2>
<p>MTAPI supports two programming modes derived from use cases of the working group members:</p><ul>
<li><b>Tasks</b><br />
 MTAPI allows a programmer to start tasks and to synchronize on task completion. Tasks are executed by the runtime system, concurrently to other tasks that have been started and have not been completed at that point in time. A task can be implemented by software or by hardware. Tasks can be started from remote nodes, i.e., the implementation can be done on one node, but the starting and synchronization of corresponding tasks can be done on other nodes. The developer decides where to deploy a task implementation. On the executing node, the runtime system selects the cores that execute a particular task. This mapping can be influenced by application-specific attributes. Tasks can start sub-tasks. MTAPI provides a basic mechanism to pass data to the node that executes a task, and back to the calling node.</li>
<li><b>Queues</b><br />
 Explicit queues can be used to control the task scheduling policies for related tasks. Order-preserving queues ensure that tasks are executed sequentially in queue order with no subsequent task starting until the previous one is complete. MTAPI also supports non-order-preserving queues, allowing control of the scheduling policies of tasks started via the same queue (queues may offer implementation specific scheduling policies controlled by implementation specific queue attributes). Even hardware queues can be associated with queue objects.</li>
</ul>
<p>MTAPI also supports the following types of tasks:</p><ul>
<li><b>Single tasks</b><br />
 Single tasks are the standard case: After a task is started, the application may wait for completion of the task at a later point in time. In some cases the application waits for completion of a group of tasks. In other cases waiting is not required at all. When a software-implemented task is started, the corresponding code (action function) is executed once by the MTAPI runtime environment. When a hardware-implemented task is started, the task execution is triggered once by the MTAPI runtime system.</li>
<li><b>Multi-instance tasks</b><br />
 Multi-instance tasks execute the same action multiple times in parallel (similar to parallel regions in OpenMP or parallel MPI processes).</li>
<li><b>Multiple-implementation tasks / load balancing</b><br />
 In heterogeneous systems, there could be implementations of the same job for different types of processor cores, e.g., one general purpose implementation and a second one for a hardware accelerator. MTAPI allows attaching multiple actions to a job. The runtime system shall decide dynamically during runtime, depending on the system load, which action to utilize. Only one of the alternative actions will be executed. </li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jun 27 2017 04:05:15 for Embedded Multicore Building Blocks V1.0.0 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
