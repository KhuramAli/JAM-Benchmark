<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link href="data:text/css;charset=utf-8,%0A%0Ahtml%20%7B%0Afont%2Dsize%3A%20100%25%3B%0Aoverflow%2Dy%3A%20scroll%3B%0A%2Dwebkit%2Dtext%2Dsize%2Dadjust%3A%20100%25%3B%0A%2Dms%2Dtext%2Dsize%2Dadjust%3A%20100%25%3B%0A%7D%0Abody%20%7B%0Acolor%3A%20%23444%3B%0Afont%2Dfamily%3A%20Georgia%2C%20Palatino%2C%20%27Palatino%20Linotype%27%2C%20Times%2C%20%27Times%20New%20Roman%27%2C%20serif%3B%0Afont%2Dsize%3A%2012px%3B%0Aline%2Dheight%3A%201%2E7%3B%0Apadding%3A%201em%3B%0Amargin%3A%20auto%3B%0Amax%2Dwidth%3A%2042em%3B%0Abackground%3A%20%23fefefe%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230645ad%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%230b0080%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%2306e%3B%0A%7D%0Aa%3Aactive%20%7B%0Acolor%3A%20%23faa700%3B%0A%7D%0Aa%3Afocus%20%7B%0Aoutline%3A%20thin%20dotted%3B%0A%7D%0A%2A%3A%3A%2Dmoz%2Dselection%20%7B%0Abackground%3A%20rgba%28255%2C%20255%2C%200%2C%200%2E3%29%3B%0Acolor%3A%20%23000%3B%0A%7D%0A%2A%3A%3Aselection%20%7B%0Abackground%3A%20rgba%28255%2C%20255%2C%200%2C%200%2E3%29%3B%0Acolor%3A%20%23000%3B%0A%7D%0Aa%3A%3A%2Dmoz%2Dselection%20%7B%0Abackground%3A%20rgba%28255%2C%20255%2C%200%2C%200%2E3%29%3B%0Acolor%3A%20%230645ad%3B%0A%7D%0Aa%3A%3Aselection%20%7B%0Abackground%3A%20rgba%28255%2C%20255%2C%200%2C%200%2E3%29%3B%0Acolor%3A%20%230645ad%3B%0A%7D%0Ap%20%7B%0Amargin%3A%201em%200%3B%0A%7D%0Aimg%20%7B%0Amax%2Dwidth%3A%20100%25%3B%0A%7D%0Ah1%2C%20h2%2C%20h3%2C%20h4%2C%20h5%2C%20h6%20%7B%0Acolor%3A%20%23111%3B%0Aline%2Dheight%3A%20125%25%3B%0Amargin%2Dtop%3A%202em%3B%0Afont%2Dweight%3A%20normal%3B%0A%7D%0Ah4%2C%20h5%2C%20h6%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Ah1%20%7B%0Afont%2Dsize%3A%202%2E5em%3B%0A%7D%0Ah2%20%7B%0Afont%2Dsize%3A%202em%3B%0A%7D%0Ah3%20%7B%0Afont%2Dsize%3A%201%2E5em%3B%0A%7D%0Ah4%20%7B%0Afont%2Dsize%3A%201%2E2em%3B%0A%7D%0Ah5%20%7B%0Afont%2Dsize%3A%201em%3B%0A%7D%0Ah6%20%7B%0Afont%2Dsize%3A%200%2E9em%3B%0A%7D%0Ablockquote%20%7B%0Acolor%3A%20%23666666%3B%0Amargin%3A%200%3B%0Apadding%2Dleft%3A%203em%3B%0Aborder%2Dleft%3A%200%2E5em%20%23EEE%20solid%3B%0A%7D%0Ahr%20%7B%0Adisplay%3A%20block%3B%0Aheight%3A%202px%3B%0Aborder%3A%200%3B%0Aborder%2Dtop%3A%201px%20solid%20%23aaa%3B%0Aborder%2Dbottom%3A%201px%20solid%20%23eee%3B%0Amargin%3A%201em%200%3B%0Apadding%3A%200%3B%0A%7D%0Apre%2C%20code%2C%20kbd%2C%20samp%20%7B%0Amargin%3A%200%3B%0Acolor%3A%20%23000%3B%0Afont%2Dfamily%3A%20monospace%2C%20monospace%3B%0A%5Ffont%2Dfamily%3A%20%27courier%20new%27%2C%20monospace%3B%0Afont%2Dsize%3A%200%2E98em%3B%0A%2Depub%2Dhyphens%3A%20none%3B%0A%7D%0Apre%20%7B%0Awhite%2Dspace%3A%20pre%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%0Aword%2Dwrap%3A%20break%2Dword%3B%0A%7D%0Ab%2C%20strong%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Adfn%20%7B%0Afont%2Dstyle%3A%20italic%3B%0A%7D%0Ains%20%7B%0Abackground%3A%20%23ff9%3B%0Acolor%3A%20%23000%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Amark%20%7B%0Abackground%3A%20%23ff0%3B%0Acolor%3A%20%23000%3B%0Afont%2Dstyle%3A%20italic%3B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Asub%2C%20sup%20%7B%0Afont%2Dsize%3A%2075%25%3B%0Aline%2Dheight%3A%200%3B%0Aposition%3A%20relative%3B%0Avertical%2Dalign%3A%20baseline%3B%0A%7D%0Asup%20%7B%0Atop%3A%20%2D0%2E5em%3B%0A%7D%0Asub%20%7B%0Abottom%3A%20%2D0%2E25em%3B%0A%7D%0Aul%2C%20ol%20%7B%0Amargin%3A%201em%200%3B%0Apadding%3A%200%200%200%202em%3B%0A%7D%0Ali%20p%3Alast%2Dchild%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Aul%20ul%2C%20ol%20ol%20%7B%0Amargin%3A%20%2E3em%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dbottom%3A%201em%3B%0A%7D%0Adt%20%7B%0Afont%2Dweight%3A%20bold%3B%0Amargin%2Dbottom%3A%20%2E8em%3B%0A%7D%0Add%20%7B%0Amargin%3A%200%200%20%2E8em%202em%3B%0A%7D%0Add%3Alast%2Dchild%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Aimg%20%7B%0Aborder%3A%200%3B%0A%2Dms%2Dinterpolation%2Dmode%3A%20bicubic%3B%0Avertical%2Dalign%3A%20middle%3B%0A%7D%0Afigure%20%7B%0Adisplay%3A%20block%3B%0Atext%2Dalign%3A%20center%3B%0Amargin%3A%201em%200%3B%0A%7D%0Afigure%20img%20%7B%0Aborder%3A%20none%3B%0Amargin%3A%200%20auto%3B%0A%7D%0Afigcaption%20%7B%0Afont%2Dsize%3A%200%2E8em%3B%0Afont%2Dstyle%3A%20italic%3B%0Amargin%3A%200%200%20%2E8em%3B%0A%7D%0Atable%20%7B%0Amargin%2Dbottom%3A%202em%3B%0Aborder%2Dbottom%3A%201px%20solid%20%23ddd%3B%0Aborder%2Dright%3A%201px%20solid%20%23ddd%3B%0Aborder%2Dspacing%3A%200%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Apadding%3A%20%2E2em%201em%3B%0Abackground%2Dcolor%3A%20%23eee%3B%0Aborder%2Dtop%3A%201px%20solid%20%23ddd%3B%0Aborder%2Dleft%3A%201px%20solid%20%23ddd%3B%0A%7D%0Atable%20td%20%7B%0Apadding%3A%20%2E2em%201em%3B%0Aborder%2Dtop%3A%201px%20solid%20%23ddd%3B%0Aborder%2Dleft%3A%201px%20solid%20%23ddd%3B%0Avertical%2Dalign%3A%20top%3B%0A%7D%0A%2Eauthor%20%7B%0Afont%2Dsize%3A%201%2E2em%3B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%40media%20only%20screen%20and%20%28min%2Dwidth%3A%20480px%29%20%7B%0Abody%20%7B%0Afont%2Dsize%3A%2014px%3B%0A%7D%0A%7D%0A%40media%20only%20screen%20and%20%28min%2Dwidth%3A%20768px%29%20%7B%0Abody%20%7B%0Afont%2Dsize%3A%2016px%3B%0A%7D%0A%7D%0A%40media%20print%20%7B%0A%2A%20%7B%0Abackground%3A%20transparent%20%21important%3B%0Acolor%3A%20black%20%21important%3B%0Afilter%3A%20none%20%21important%3B%0A%2Dms%2Dfilter%3A%20none%20%21important%3B%0A%7D%0Abody%20%7B%0Afont%2Dsize%3A%2012pt%3B%0Amax%2Dwidth%3A%20100%25%3B%0A%7D%0Aa%2C%20a%3Avisited%20%7B%0Atext%2Ddecoration%3A%20underline%3B%0A%7D%0Ahr%20%7B%0Aheight%3A%201px%3B%0Aborder%3A%200%3B%0Aborder%2Dbottom%3A%201px%20solid%20black%3B%0A%7D%0Aa%5Bhref%5D%3Aafter%20%7B%0Acontent%3A%20%22%20%28%22%20attr%28href%29%20%22%29%22%3B%0A%7D%0Aabbr%5Btitle%5D%3Aafter%20%7B%0Acontent%3A%20%22%20%28%22%20attr%28title%29%20%22%29%22%3B%0A%7D%0A%2Eir%20a%3Aafter%2C%20a%5Bhref%5E%3D%22javascript%3A%22%5D%3Aafter%2C%20a%5Bhref%5E%3D%22%23%22%5D%3Aafter%20%7B%0Acontent%3A%20%22%22%3B%0A%7D%0Apre%2C%20blockquote%20%7B%0Aborder%3A%201px%20solid%20%23999%3B%0Apadding%2Dright%3A%201em%3B%0Apage%2Dbreak%2Dinside%3A%20avoid%3B%0A%7D%0Atr%2C%20img%20%7B%0Apage%2Dbreak%2Dinside%3A%20avoid%3B%0A%7D%0Aimg%20%7B%0Amax%2Dwidth%3A%20100%25%20%21important%3B%0A%7D%0A%40page%20%3Aleft%20%7B%0Amargin%3A%2015mm%2020mm%2015mm%2010mm%3B%0A%7D%0A%40page%20%3Aright%20%7B%0Amargin%3A%2015mm%2010mm%2015mm%2020mm%3B%0A%7D%0Ap%2C%20h2%2C%20h3%20%7B%0Aorphans%3A%203%3B%0Awidows%3A%203%3B%0A%7D%0Ah2%2C%20h3%20%7B%0Apage%2Dbreak%2Dafter%3A%20avoid%3B%0A%7D%0A%7D%0A" rel="stylesheet" type="text/css" />
</head>
<body>
<h1 id="embedded-multicore-building-blocks-tutorial">Embedded Multicore Building Blocks Tutorial</h1>
<h2 id="contents">Contents</h2>
<p><a href="#cha_introduction"><strong>Introduction</strong></a><br />
  <a href="#sec_introduction_overview">Overview</a><br />
  <a href="#sec_introduction_outline">Outline</a><br />
  <a href="#sec_introduction_function_objects">Functions, Functors, and Lambdas</a></p>
<p><a href="#cha_algorithms"><strong>Algorithms</strong></a><br />
  <a href="#sec_algorithms_invoke">Function Invocation</a><br />
  <a href="#sec_algorithms_sorting">Sorting</a><br />
  <a href="#sec_algorithms_counting">Counting</a><br />
  <a href="#sec_algorithms_foreach">Foreach Loops</a><br />
  <a href="#sec_algorithms_reductions">Reductions</a><br />
  <a href="#sec_algorithms_prefix">Prefix Computations</a></p>
<p><a href="#cha_dataflow"><strong>Dataflow</strong></a><br />
  <a href="#sec_dataflow_linear_pipelines">Linear Pipelines</a><br />
  <a href="#sec_dataflow_nonlinear_pipelines">Nonlinear Pipelines</a></p>
<p><a href="#cha_containers"><strong>Containers</strong></a><br />
  <a href="#sec_containers_object_pools">Object Pools</a><br />
  <a href="#sec_containers_stacks">Stacks</a><br />
  <a href="#sec_containers_queues">Queues</a></p>
<p><a href="#cha_mtapi"><strong>MTAPI</strong></a><br />
  <a href="#sec_mtapi_foundations">Foundations</a><br />
  <a href="#sec_mtapi_c_interface">C Interface</a><br />
  <a href="#sec_mtapi_cpp_interface">C++ Interface</a><br />
  <a href="#sec_mtapi_plugins">Plugins</a></p>
<p><a href="#cha_heterogeneous_systems"><strong>Heterogeneous Systems</strong></a><br />
  <a href="#sec_algorithms_heterogeneous_systems">Algorithms</a><br />
  <a href="#sec_dataflow_heterogeneous_systems">Dataflow</a></p>
<p><a href="#cha_tutorial_application"><strong>Tutorial Application</strong></a></p>
<p><a href="#cha_bibliography"><strong>Bibliography</strong></a></p>
<h2 id="introduction"><a name="cha_introduction"></a>Introduction</h2>
<h3 id="overview"><a name="sec_introduction_overview"></a>Overview</h3>
<p>The Embedded Multicore Building Blocks (EMB²) are an easy to use yet powerful and efficient C/C++ library for the development of parallel applications. EMB² has been specifically designed for embedded systems and the typical requirements that accompany them, such as real-time capability and constraints on memory consumption. As a major advantage, low-level operations are hidden in the library which relieves software developers from the burden of thread management and synchronization. This not only improves productivity of parallel software development, but also results in increased reliability and performance of the applications.</p>
<p>EMB² is independent of the hardware architecture (x86, ARM, ...) and runs on various platforms, from small devices to large systems containing numerous processor cores. It builds on MTAPI, a standardized programming interface for leveraging task parallelism in embedded systems containing symmetric or asymmetric (heterogeneous) multicore processors. A core feature of MTAPI is low-overhead scheduling of fine-grained tasks among the available cores during runtime. Unlike existing libraries, EMB² supports task priorities and affinities, which allows the creation of soft real-time systems. Additionally, the scheduling strategy can be optimized for non-functional requirements such as minimal latency and fairness.</p>
<p>Besides the task scheduler, EMB² provides basic parallel algorithms, concurrent data structures, and skeletons for implementing stream processing applications (see <a href="#fig_embb">Figure 1</a>). These building blocks are largely implemented in a non-blocking fashion, thus preventing frequently encountered pitfalls like lock contention, deadlocks, and priority inversion. As another advantage in real-time systems, the algorithms and data structures give certain progress guarantees. For example, wait-free data structures guarantee system-wide progress which means that every operation completes within a finite number of steps independently of any other concurrent operations on the same data structure.</p>
<p><img src="data:image/png;base64,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" alt="Figure 1: Main Building Blocks of EMB²" /> <a name="fig_embb"></a><strong>Figure 1</strong>: Main Building Blocks of EMB²</p>
<h3 id="outline"><a name="sec_introduction_outline"></a>Outline</h3>
<p>The purpose of this document is to introduce the basic concepts of EMB² and to demonstrate typical application scenarios by means of simple examples. The tutorial is not intended to be complete in the sense that it describes every feature of EMB². For a detailed description of the API, please see the reference manual.</p>
<p>In the next subsection, we briefly describe the concept of <a href="#sec_introduction_function_objects">function objects</a> which is essential for using EMB². We then present various parallel <a href="#cha_algorithms">algorithms</a> and the <a href="#cha_dataflow">dataflow</a> framework. After that, we explain the usage of <a href="#cha_mtapi">MTAPI</a> and how to leverage <a href="#cha_heterogeneous_systems">heterogeneous systems</a>. The complete source code for the examples presented in the following can be found in the <code>examples</code> directory.</p>
<h3 id="functions-functors-and-lambdas"><a name="sec_introduction_function_objects"></a>Functions, Functors, and Lambdas</h3>
<p>Throughout this tutorial, we will encounter C++ types which model the C++ concept <code>FunctionObject</code>. The function object concept comprises function pointer, functor, and lambda types that are callable with suitable arguments by the function call syntax. Given a function object <code>f</code> and arguments <code>arg1</code>, <code>arg2</code>, <code>...</code>, the expression <code>f(arg1, arg2, ...)</code> is a valid function invocation. If you are already familiar with function objects, you can safely skip the rest of this section. Otherwise, it might be worth reading it to get an idea of what is meant when talking about a function objects.</p>
<p>Consider, for example, the transformation of an iterable range of data values. Specifically, consider a vector of integers initialized as follows:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::vector&lt;<span class="dt">int</span>&gt; range(<span class="dv">5</span>);
<span class="kw">for</span> (size_t i=<span class="dv">0</span>; i &lt; range.size(); i++) {
  range[i] = <span class="kw">static_cast</span>&lt;<span class="dt">int</span>&gt;(i) + <span class="dv">1</span>;
}</code></pre></div>
<p>The range consists of the values <code>(1, 2, 3, 4, 5)</code>. To double each value, we could simply iterate over the vector as follows:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">for</span> (size_t i=<span class="dv">0</span>; i &lt; range.size(); i++) {
  range[i] *= <span class="dv">2</span>;
}</code></pre></div>
<p>The range then contains the values <code>(2, 4, 6, 8, 10)</code>. In order to demonstrate the concept of function objects, we are now going to use the <code>std::for_each</code> function defined in the <code>algorithm</code> header of the C++ Standard Library. This function accepts as argument a <code>UnaryFunction</code>, that is, a function object which takes only one argument. In case of <code>std::for_each</code>, the argument has to have the same type as the elements in the range, as these are passed to the unary function. In our example, the unary function’s task is to double the passed value. We could define a function for that purpose:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> DoubleFunction(<span class="dt">int</span>&amp; to_double) {
  to_double *= <span class="dv">2</span>;
}</code></pre></div>
<p>Since a function pointer models the concept of function objects, we can simply pass <code>&amp;DoubleFunction</code> to <code>std::for_each</code>:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::for_each(range.begin(), range.end(), &amp;DoubleFunction);</code></pre></div>
<p>Another possibility is to define a functor</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> DoubleFunctor {
  <span class="dt">void</span> <span class="kw">operator</span>()(<span class="dt">int</span>&amp; to_double) {
    to_double *= <span class="dv">2</span>;
  }
};</code></pre></div>
<p>and to pass an instance of this class to <code>std::for_each</code>:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::for_each(range.begin(), range.end(), DoubleFunctor());</code></pre></div>
<p>Functors as well as function pointers separate the actual implementation from its usage which can be helpful if the functionality is needed at different places. In many cases, however, it is easier to have the implementation of the function object at the same place as it is used. C++11 provides lambda expressions for that purpose which make our example more concise:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::for_each(range.begin(), range.end(),
              [] (<span class="dt">int</span>&amp; to_double) { to_double *= <span class="dv">2</span>; });</code></pre></div>
<p>Of course, this example is too simple to really benefit from function objects and the algorithms contained in the C++ Standard Library. However, in combination with the parallelization features provided by EMB², function objects are very useful. Within this document, whenever a function object or one of its subtypes is required, one can use a function pointer, a functor, or a lambda. For simplicity, we will restrict ourselves to lambdas in subsequent examples, as they are most suitable for this tutorial.</p>
<h2 id="algorithms"><a name="cha_algorithms"></a>Algorithms</h2>
<p>The <em>Algorithms</em> building block of EMB² provides high-level constructs for typical parallelization tasks. They are similar to the functions provided by the C++ Standard Library, but contain additional functionality typical for embedded systems such as task priorities. Although the algorithms can be used in a black-box way, it is good to have a basic understanding of their implementation: The algorithms split computations to be performed in parallel into tasks which are executed by the MTAPI task scheduler (see chapter on <a href="#cha_mtapi">MTAPI</a>). For that purpose, the tasks are stored in queues and mapped to a fixed number of worker threads at runtime.</p>
<p><em><strong>Note:</strong> The algorithms are implemented using the MTAPI C++ interface. Since MTAPI allocates the necessary data structures during initialization, the maximum number of tasks in flight is fixed. In case one of the algorithms exceeds this limit, an exception is thrown. By calling <code>embb::mtapi::Node::Initialize</code>, the maximum number of tasks and other limits can be customized. Explicit initialization also eliminates unexpected delays when measuring performance. See the section on the <a href="#sec_mtapi_cpp_interface">MTAPI C++ Interface</a> for details.</em></p>
<h3 id="function-invocation"><a name="sec_algorithms_invoke"></a>Function Invocation</h3>
<p>Let us start with the parallel execution of several work packages encapsulated in functions. Suppose that the following functions operate on different data sets and are thus independent of each other:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> WorkPackageA();
<span class="dt">void</span> WorkPackageB();
<span class="dt">void</span> WorkPackageC();</code></pre></div>
<p>The functions can be executed in parallel using the <code>ParallelInvoke</code> construct provided by EMB²:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> embb::algorithms::Invoke;
Invoke(WorkPackageA, WorkPackageB, WorkPackageC);</code></pre></div>
<p>Note that <code>ParallelInvoke</code> waits until all its arguments have finished execution.</p>
<p>Next, let us consider a more elaborate example. The following piece of code shows a sequential implementation of the quicksort algorithm, which we want to parallelize (do not care about the details of the <code>Partition</code> function for the moment):</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> QuickSort(<span class="dt">int</span>* first, <span class="dt">int</span>* last) {
  <span class="kw">if</span> (last - first &lt;= <span class="dv">1</span>) <span class="kw">return</span>;
  <span class="dt">int</span>* mid = Partition(first, last);
  QuickSort(first, mid);
  QuickSort(mid, last);
}</code></pre></div>
<p>A straightforward approach to parallelize this algorithm is to execute the recursive calls to <code>Quicksort</code> in parallel. With <code>ParallelInvoke</code> and lambdas, it is as simple as that:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> ParallelQuickSort(<span class="dt">int</span>* first, <span class="dt">int</span>* last) {
  <span class="kw">if</span> (last - first &lt;= <span class="dv">1</span>) <span class="kw">return</span>;
  <span class="dt">int</span>* mid = Partition(first, last);
  <span class="kw">using</span> embb::algorithms::Invoke;
  Invoke([=](){ParallelQuickSort(first, mid);},
         [=](){ParallelQuickSort(mid, last);});
}</code></pre></div>
<p>The lambdas capture the <code>first</code>, <code>mid</code>, and <code>last</code> pointers to the range to be sorted and forward them to the recursive calls of quicksort. These are executed in parallel, where <code>Invoke</code> does not return before both have finished execution. The above implementation of parallel quicksort is not yet optimal. In particular, the creation of new tasks should be stopped when a certain lower bound on the size of the subranges has been reached. The subranges can then be sorted sequentially in order to reduce the overhead for task creation and management. Fortunately, EMB² already provides solutions for parallel sorting, which will be covered in the following section.</p>
<h3 id="sorting"><a name="sec_algorithms_sorting"></a>Sorting</h3>
<p>For systems with constraints on memory consumption, the quicksort implementation provided by EMB² is usually the best choice, since it works in-place, which means that it does not require additional memory. Considering real-time systems, however, its worst-case runtime of <em>O(n<sup>2</sup>)</em>, where <em>n</em> is the number of elements to be sorted, can be a problem. For this reason, EMB² also provides a parallel merge sort algorithm. Merge sort does not work in-place, but has a predictable runtime complexity of <em>ϴ(n log n)</em>. Assume we want to sort a vector of integers:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::vector&lt;<span class="dt">int</span>&gt; range;</code></pre></div>
<p>Using quicksort, we simply write:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> embb::algorithms::QuickSort;
QuickSort(range.begin(), range.end());</code></pre></div>
<p>The default invocation of <code>QuickSort</code> uses <code>std::less</code> with the iterators’ <code>value_type</code> as comparison operation. As a result, the range is sorted in ascending order. It is possible to provide a custom comparison operation, for example <code>std::greater</code>, by passing it as a function object to the algorithm. Sorting the elements in descending can be accomplished as follows:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">QuickSort(range.begin(), range.end(), std::greater&lt;<span class="dt">int</span>&gt;());</code></pre></div>
<p>The merge sort algorithm comes in two versions. The first version automatically allocates dynamic memory for temporary values when the algorithm is called. Its name is <code>MergeSortAllocate</code> and it has the same parameters as <code>QuickSort</code>. To enable the use of merge sort in environments that forbid dynamic memory allocation after initialization, the second version can be called with a pre-allocated temporary range of values:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> embb::algorithms::MergeSort;
std::vector&lt;<span class="dt">int</span>&gt; temporary_range(range.size());
MergeSort(range.begin(), range.end(), temporary_range.begin());</code></pre></div>
<p>The temporary range can be allocated at any time, e.g., during the initialization phase of the system.</p>
<h3 id="counting"><a name="sec_algorithms_counting"></a>Counting</h3>
<p>EMB² also provides functions for counting the number of elements in a range. Consider a range of integers from 0 to 3:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> range[] = {<span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">2</span>};</code></pre></div>
<p>To determine how often a specific value appears within the range, we could simply iterate over it and compare each element with the specified one. The <code>Count</code> function does this in parallel, where the first two arguments specify the range and the third one the element to be counted:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::iterator_traits&lt;<span class="dt">int</span>*&gt;::difference_type count;
<span class="kw">using</span> embb::algorithms::Count;
count = Count(range, range + <span class="dv">8</span>, <span class="dv">1</span>);</code></pre></div>
<p>For the range given above, we have <code>count == 2</code>.</p>
<p>In case the comparison operation is not equality, we can employ the <code>CountIf</code> function. Here, the third argument is a unary predicate which evaluates to <code>true</code> for each element to be counted. The following example shows how to count the number of values greater than 0:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> embb::algorithms::CountIf;
count = CountIf(range, range + <span class="dv">8</span>,
                [](<span class="dt">const</span> <span class="dt">int</span>&amp; value) -&gt; <span class="dt">bool</span> { <span class="kw">return</span> value &gt; <span class="dv">0</span>; });</code></pre></div>
<h3 id="foreach-loops"><a name="sec_algorithms_foreach"></a>Foreach Loops</h3>
<p>A frequently encountered task in parallel programming is to apply some operation to a range of values, as illustrated previously. In principle, one could apply the operation to all elements in parallel provided that there are no data dependencies. However, this results in unnecessary overhead if the number of elements is greater than the number of available processor cores <em>p</em>. A better solution is to partition the range into <em>p</em> blocks and to process the elements of a block sequentially. With the <code>ForEach</code> construct provided by EMB², users do not have to care about the partitioning, since this is done automatically. Similar to the Standard Library’s <code>for_each</code> function, it is sufficient to pass the operation in form of a function object. The following piece of code shows how to double the elements of a range in parallel:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> embb::algorithms::ForEach;
ForEach(range.begin(), range.end(),
        [] (<span class="dt">int</span>&amp; to_double) { to_double *= <span class="dv">2</span>; });</code></pre></div>
<p>There is also a <code>ForLoop</code> variant that accepts integers as limits of the range:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> embb::algorithms::ForLoop;
ForLoop(<span class="dv">0</span>, <span class="dt">int</span>(range.size()),
  [&amp;](<span class="dt">int</span> to_double) { range[size_t(to_double)] = (to_double + <span class="dv">1</span>) * <span class="dv">2</span>; });</code></pre></div>
<p>In the above code snippet, the results of the computation overwrite the input. If the input has to be left unchanged, the results must be written to a separate output range. Thus, the operation requires two ranges. EMB² supports such scenarios by the <code>ZipIterator</code>, which wraps two iterators into one. Consider the following revised example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::vector&lt;<span class="dt">int</span>&gt; input_range(<span class="dv">5</span>);
<span class="kw">for</span> (size_t i=<span class="dv">0</span>; i &lt; input_range.size(); i++) {
  input_range[i] = <span class="kw">static_cast</span>&lt;<span class="dt">int</span>&gt;(i) + <span class="dv">1</span>;
}
std::vector&lt;<span class="dt">int</span>&gt; output_range(<span class="dv">5</span>);</code></pre></div>
<p>Using the <code>Zip</code> function as a convenient way to create a zip iterator, the doubling of elements can be performed as follows:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> embb::algorithms::Zip;
<span class="kw">using</span> embb::algorithms::ZipPair;
ForEach(Zip(input_range.begin(), output_range.begin()),
        Zip(input_range.end(), output_range.end()),
        [] (ZipPair&lt;<span class="dt">int</span>&amp;, <span class="dt">int</span>&amp;&gt; pair) {
          pair.Second() = pair.First() * <span class="dv">2</span>;
        });</code></pre></div>
<p>The argument to the lambda function is a <code>ZipPair</code> with the iterators’ reference value as template parameters. The elements pointed to by the zip iterator can be accessed via <code>First()</code> and <code>Second()</code>, similar to <code>std::pair</code>.</p>
<h3 id="reductions"><a name="sec_algorithms_reductions"></a>Reductions</h3>
<p>As mentioned in the previous section, the <code>ForEach</code> construct requires the loop iterations do be independent of each other. However, this is not always the case. Imagine we want to sum up the values of a range, e.g., a vector of integers:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::vector&lt;<span class="dt">int</span>&gt; range(<span class="dv">5</span>);
<span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; range.size(); i++) {
  range[i] = <span class="kw">static_cast</span>&lt;<span class="dt">int</span>&gt;(i) + <span class="dv">1</span>;
}</code></pre></div>
<p>Sequentially, this can be done by a simple loop:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> sum = <span class="dv">0</span>;
<span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; range.size(); i++) {
  sum += range[i];
}</code></pre></div>
<p>One might be tempted to sum up the elements in parallel using a foreach loop. The problem is that parallel accesses to <code>sum</code> must be synchronized to avoid race conditions, which in fact sequentializes the loop. A more efficient approach is to compute intermediate sums for each block of the range and to sum them up at the end. For such purposes, EMB² provides the function <code>Reduce</code>:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> embb::algorithms::Reduce;
sum = Reduce(range.begin(), range.end(), <span class="dv">0</span>, std::plus&lt;<span class="dt">int</span>&gt;());</code></pre></div>
<p>The third argument to <code>Reduce</code> is the neutral element of the reduction operation, i.e., the element that does not change the result. In case of addition (<code>std::plus</code>), the neutral element is 0. If we wanted to compute the product of the vector elements, the neutral element would be 1.</p>
<p>Next, let us consider the parallel computation of a dot product. Given two input ranges, we want to multiply each pair of input elements and sum up the products. The second input range is given as follows:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::vector&lt;<span class="dt">int</span>&gt; second_range(<span class="dv">5</span>);
<span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; range.size(); i++) {
  second_range[i] = <span class="kw">static_cast</span>&lt;<span class="dt">int</span>&gt;(i) + <span class="dv">5</span>;
}</code></pre></div>
<p>The reduction consists of two steps: First, the input ranges are transformed and then, the reduction is performed on the transformed range. For that purpose, the <code>Reduce</code> function allows to specify a transformation function object. By default, this is the identity functor which does not modify the input range. To implement the dot product, we can use the <code>Zip</code> function and a lambda function for computing the transformed range:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> embb::algorithms::Zip;
<span class="kw">using</span> embb::algorithms::ZipPair;
<span class="dt">int</span> dot_product = Reduce(Zip(range.begin(), second_range.begin()),
                         Zip(range.end(), second_range.end()),
                         <span class="dv">0</span>,
                         std::plus&lt;<span class="dt">int</span>&gt;(),
                         [](<span class="dt">const</span> ZipPair&lt;<span class="dt">int</span>&amp;, <span class="dt">int</span>&amp;&gt;&amp; pair) {
                           <span class="kw">return</span> pair.First() * pair.Second();
                         });</code></pre></div>
<h3 id="prefix-computations"><a name="sec_algorithms_prefix"></a>Prefix Computations</h3>
<p>Prefix computations (or scans) can be viewed as a generalization of reductions. They transform an input range <em>x<sub>i</sub></em> into an output range <em>y<sub>i</sub></em> with <em>i=1,...,n</em> such that</p>
<p><em>y<sub>0</sub> = id · x<sub>0</sub></em><br />
<em>y<sub>1</sub> = y<sub>0</sub> · x<sub>1</sub></em><br />
  ⁞<br />
<em>y<sub>i</sub> = y<sub>i-1</sub> · x<sub>i</sub></em><br />
  ⁞<br />
<em>y<sub>n</sub> = y<sub>n-1</sub> · x<sub>n</sub></em>,</p>
<p>where <em>id</em> is the identity (neutral element) with respect to the <em>·</em> operation. As an example, consider the following range:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::vector&lt;<span class="dt">int</span>&gt; input_range(<span class="dv">5</span>);
<span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; input_range.size(); i++) {
  input_range[i] = <span class="kw">static_cast</span>&lt;<span class="dt">int</span>&gt;(i) + <span class="dv">1</span>;
}</code></pre></div>
<p>Computing the prefix sums of <code>input_range</code> sequentially is easy:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::vector&lt;<span class="dt">int</span>&gt; output_range(input_range.size());
output_range[<span class="dv">0</span>] = input_range[<span class="dv">0</span>];
<span class="kw">for</span>(size_t i = <span class="dv">1</span>; i &lt; input_range.size(); i++) {
  output_range[i] = output_range[i<span class="dv">-1</span>] + input_range[i];
}</code></pre></div>
<p>Note the dependency on loop iteration <em>i-1</em> to compute the result in iteration <em>i</em>. A special two-pass algorithm is used in the function <code>Scan</code> to perform prefix computations in parallel. Using <code>Scan</code> to compute the prefix sums, we get:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> embb::algorithms::Scan;
Scan(input_range.begin(), input_range.end(), output_range.begin(),
     <span class="dv">0</span>, std::plus&lt;<span class="dt">int</span>&gt;());</code></pre></div>
<p>As in the case of reductions, the neutral element has to be given explicitly. Also, a transformation function can be passed as additional argument to <code>Scan</code>. The elements of the input range are then transformed before passed to the prefix operation.</p>
<h2 id="dataflow"><a name="cha_dataflow"></a>Dataflow</h2>
<p>EMB² provides generic skeletons for the development of parallel stream-based applications. These skeletons are based on dataflow networks, a model of computation widely employed in different domains like digital signal processing and imaging due to its simplicity and flexibility. As a major advantage, these networks are deterministic which significantly simplifies testing and debugging. This is particularly important in embedded systems, where high demands are put on correctness and reliability. Moreover, they are inherently parallel and lend themselves well for execution on a multicore processor. In fact, they can be viewed as a generalization of pipelining, a frequently encountered parallel pattern.</p>
<p><em><strong>Note:</strong> Dataflow networks are internally implemented using the MTAPI C++ interface. Since MTAPI does not allocate memory after initialization, the number of tasks and other resources are limited. By calling <code>embb::mtapi::Node::Initialize</code>, these limits can be customized. Explicit initialization also eliminates unexpected delays when measuring performance. See the section on the <a href="#sec_mtapi_cpp_interface">MTAPI C++ Interface</a> for details.</em></p>
<h3 id="linear-pipelines"><a name="sec_dataflow_linear_pipelines"></a>Linear Pipelines</h3>
<p>Before we go into detail, we demonstrate the basic concepts of dataflow networks by means of a simple application which finds and replaces strings in a file. Let us start with the sequential implementation. The program shown in <a href="#lst_replace_seq">Listing 1</a> reads a file line by line and replaces each occurrence of a given string with a new string.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;fstream&gt;</span>
<span class="ot">#include &lt;string&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// replace all ocurrences of 'what' in 'str' with 'with'</span>
<span class="dt">void</span> repl(string&amp; str, <span class="dt">const</span> string &amp;what,
          <span class="dt">const</span> string&amp; with) {
  string::size_type pos = <span class="dv">0</span>;
  <span class="kw">while</span>((pos = str.find(what, pos)) != string::npos) {
    str.replace(pos, what.length(), with);
    pos += with.length();
  }
}

<span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[]) {
  <span class="co">// check and read command line arguments</span>
  <span class="kw">if</span>(argc != <span class="dv">4</span>) {
    cerr &lt;&lt; <span class="st">&quot;Usage: replace &lt;what&gt; &lt;with&gt; &lt;file&gt;&quot;</span> &lt;&lt; endl;
    exit(EXIT_FAILURE);
  }
  <span class="dt">const</span> string what(argv[<span class="dv">1</span>]), with(argv[<span class="dv">2</span>]);

  <span class="co">// open input file</span>
  ifstream file(argv[<span class="dv">3</span>]);
  <span class="kw">if</span>(!file) {
    cerr &lt;&lt; <span class="st">&quot;Cannot open file &quot;</span> &lt;&lt; argv[<span class="dv">3</span>] &lt;&lt; endl;
    exit(EXIT_FAILURE);
  }

  <span class="co">// read input file line by line and replace strings</span>
  string str;
  <span class="kw">while</span>(getline(file, str)) {
    repl(str, what, with);
    cout &lt;&lt; str &lt;&lt; endl;
  }

  <span class="co">// close file and exit</span>
  file.close();
  exit(EXIT_SUCCESS);
}</code></pre></div>
<p><a name="lst_replace_seq"></a><strong>Listing 1</strong>: Sequential program for replacing strings in a file</p>
<p>The main part consists of the <code>while</code> loop which performs three steps:</p>
<ol style="list-style-type: decimal">
<li>read a line from <code>file</code> and store it in the string <code>str</code></li>
<li>replace each occurrence of <code>what</code> in <code>str</code> with <code>with</code></li>
<li>write the resulting string to <code>cout</code></li>
</ol>
<p>To run this program on a multicore processor, we may execute the above steps in a pipelined fashion. In this way, a new line can be read from the hard disk while the previous one is still being processed. Likewise, processing a string and writing the result to standard output can be performed in parallel. Thus, the pipeline may consist of three stages as depicted in <a href="#fig_replace_par">Figure 2</a>.</p>
<p><img src="data:image/png;base64,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" alt="Figure 2: Pipeline for replacing strings in a file" /> <a name="fig_replace_par"></a><strong>Figure 2</strong>: Pipeline for replacing strings in a file</p>
<p>This pipeline can be easily implemented using the dataflow networks. As the first step, we have to include the <code>dataflow.h</code> header file:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embb/dataflow/dataflow.h&gt;</span></code></pre></div>
<p>Then, we have to construct a network. A network consists of a set of processes that are connected by communication channels. EMB² provides a class <code>Network</code> that handles data routing and scheduling of your processes:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> embb::dataflow::Network Network;</code></pre></div>
<p>We need to prepare the network for the desired maximum number of elements that can be in the network at a time. The number of elements is limited to avoid that the network is flooded with new elements before the previous elements have been processed. In a linear pipeline, for example, this may happen if the source is faster than the sink. For our example we assume that at most four elements may be processed simultaneously: one in the source, one in the sink, and two in the middle stage.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Network network(<span class="dv">4</span>);</code></pre></div>
<p>Finding an optimal value depends on the application and usually requires some experimentation. In general, large values boost the throughput but also increase the latency. Conversely, small values reduce the latency but may lead to a drop of performance in terms of throughput.</p>
<p>As the next step, we have to construct the processes shown in <a href="#fig_replace_par">Figure 2</a>. The easiest way to construct a process is to wrap the user-defined code in a lambda function and to pass it to the network. The network constructs an object for that process and executes the lambda function whenever new data is available. There are several methods for constructing processes depending on their type. The process <strong>read</strong> is a <em>source</em> process, since it produces data (by reading it from the specified file) but does not consume any data. Source processes are constructed from a function object</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> SourceFunction(std::string &amp; str) {
  <span class="kw">if</span> (!file.eof()) {
    std::getline(file, str);
    <span class="kw">return</span> <span class="kw">true</span>;
  } <span class="kw">else</span> {
    <span class="kw">return</span> <span class="kw">false</span>;
  }
}</code></pre></div>
<p>like this:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Network::Source&lt;std::string&gt; read(
  network, embb::base::MakeFunction(SourceFunction)
);</code></pre></div>
<p>Note the template argument <code>std::string</code> to <code>Source</code>. This tells that the process has exactly one <em>port</em> of type <code>std::string</code> and that this port is used to transmit data to other processes. The user-defined code can access the ports via the parameters of the function. Thus, each parameter corresponds to exactly one port. In our example, the result of the process is stored in a variable <code>str</code>, which is passed by reference.</p>
<p>The replacement of the strings can be done by a <em>parallel</em> process, which means that multiple invocations of the process may be executed simultaneously. In general, processes that neither have any side effects nor maintain a state can safely be executed in parallel. This helps to avoid bottlenecks that arise when some processes are faster than others. Suppose, for example, that <strong>replace</strong> requires up to 50 ms to execute, whereas <strong>read</strong> and <strong>write</strong> each require 10 ms to execute. If only one invocation of <strong>replace</strong> could be executed at a time, the throughput would be at most 20 elements per second. Since <strong>replace</strong> is a parallel process, however, the network may start a new invocation every 10 ms. Hence, up to five invocations may be executed in parallel, yielding a throughput of 100 elements per second. To compensate for variations in the runtime of parallel stages, they may be executed <em>out-of-order</em>. As a result, the order in which the elements of a stream enter and leave parallel stages is not necessarily preserved. In our example, the runtime of <strong>replace</strong> may vary significantly due to the fact that not all lines have the same length and that the number of replacements depends on the content. Before we go into more detail, let us first consider the following function</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> ReplaceFunction(std::string <span class="dt">const</span> &amp; istr, std::string &amp; ostr) {
  ostr = istr;
  repl(ostr, what, with);
}</code></pre></div>
<p>and how to construct the corresponding <strong>replace</strong> process:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Network::ParallelProcess&lt;
  Network::Inputs&lt;std::string&gt;,
  Network::Outputs&lt;std::string&gt; &gt; replace(
    network, embb::base::MakeFunction(ReplaceFunction)
  );</code></pre></div>
<p>The template parameter <code>Network::Inputs&lt;std::string&gt;</code> specifies that the process has one port serving as input. Analogously, <code>Network::Outputs&lt;std::string&gt;</code> specifies that there is one port serving as output.</p>
<p>Since the last process (<strong>write</strong>) does not have any outputs, we make it a <em>Sink</em>. Unlike parallel processes, sinks are always executed <em>in-order</em>. EMB² takes care that the elements are automatically reordered according to their original order in the stream. This way, the externally visible behavior is preserved even if some parallel stages may be executed out-of-order. The function</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> SinkFunction(std::string <span class="dt">const</span> &amp; str) {
  std::cout &lt;&lt; str &lt;&lt; std::endl;
}</code></pre></div>
<p>is used to construct the sink:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Network::Sink&lt;std::string&gt; write(
  network, embb::base::MakeFunction(SinkFunction)
);</code></pre></div>
<p><em><strong>Note:</strong> If you parallelize an application using EMB² and your compiler emits a lengthy error message containing lots of templates, it is very likely that for at least one process, the ports and their directions do not match the signature of the given function.</em></p>
<p>As the last step, we have to connect the processes (ports). This is straightforward using the C++ stream operator:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">read &gt;&gt; replace &gt;&gt; write;</code></pre></div>
<p>Then, we can start the network:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">network();</code></pre></div>
<p>Note that you will probably not observe a speedup when you run this program on a multicore processor. One reason for this is that I/O operations like reading a file from the hard disk and writing the output to the screen are typically a bottleneck. Moreover, the amount of work done in the middle stage of the pipeline (<strong>replace</strong>) is rather low. To outweigh the overhead for parallel execution, the amount of work must be much higher. In image processing, for example, a single pipeline stage may process a complete image. To sum up, we have chosen this example for its simplicity, not for its efficiency.</p>
<h3 id="nonlinear-pipelines"><a name="sec_dataflow_nonlinear_pipelines"></a>Nonlinear Pipelines</h3>
<p>Some applications exhibit a more complex structure than the linear pipeline presented in the previous section. Typical examples are applications where the result of a pipeline stage is used by more than one successor stage. Such pipelines are said to be nonlinear. In principle, every nonlinear pipeline can be transformed to a linear one as depicted in <a href="#fig_linearization">Figure 3</a>. However, this increases the latency and complicates the implementation due to data that must be passed through intermediate stages. In <a href="#fig_linearization">Figure 3</a>, for example, the data transferred from stage A to stage C must be passed through stage B in the linearized implementation.</p>
<p><img src="data:image/png;base64,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" alt="Figure 3: Nonlinear pipeline and linearized variant" /> <a name="fig_linearization"></a><strong>Figure 3</strong>: Nonlinear pipeline and linearized variant</p>
<p>Nonlinear pipelines can be implemented as they are using EMB², i.e., there is need not linearize them. As an example, let us consider the implementation of a sorting network. Sorting networks consist of a set of interconnected comparators and are used to sort sequences of data items. As depicted in <a href="#fig_comparator">Figure 4</a>, each comparator sorts a pair of values by putting the smaller value to one output, and the larger one to the other output. Thus, a comparator can be viewed as a switch that transfers the values at the inputs to the outputs, either directly or by swapping them (cf. <a href="#fig_example_comparator">Figure 5</a>).</p>
<p><img src="data:image/png;base64,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" alt="Figure 4: Block diagram of a comparator" /> <a name="fig_comparator"></a><strong>Figure 4</strong>: Block diagram of a comparator</p>
<p><img src="data:image/png;base64,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" alt="Figure 5: Example for the operating principle of a comparator" /> <a name="fig_example_comparator"></a><strong>Figure 5</strong>: Example for the operating principle of a comparator</p>
<p><a href="#fig_sorting_network">Figure 6</a> shows a sorting network with four inputs/outputs and five comparators. The numbers at the interconnections exemplify a “run” of the network. As can be seen from <a href="#fig_sorting_network">Figure 6</a>, the comparators <em>C<sub>1</sub>-C<sub>4</sub></em> “sink” the largest value to the bottom and “float” the smallest value to the top. The final comparator <em>C<sub>5</sub></em> simply sorts out the middle two values. This way it is guaranteed that the values at the outputs occur in ascending order.</p>
<p><img src="data:image/png;base64,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" alt="Figure 6: Sorting network with four inputs=outputs and five comparators" /> <a name="fig_sorting_network"></a><strong>Figure 6</strong>: Sorting network with four inputs/outputs and five comparators</p>
<p>Let us now consider the implementation of the sorting network using EMB². As in the previous example, we need three types of processes: one or more sources that produce a stream of data items, a total number of five processes that implement the comparators, and one or more sinks that consume the sorted sequences. The processes should be generic so that they can be used with different types. For example, in one application we might use the network to sort integers, and in another application to sort floating point values.</p>
<p>The following listing shows the implementation of the source processes using classes instead of functions (a complete implementation can be found in the examples directory):</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;
<span class="kw">class</span> Producer {
 <span class="kw">public</span>:
  <span class="kw">explicit</span> Producer(<span class="dt">int</span> seed) : seed_(seed), count_(<span class="dv">4</span>) {}
  <span class="dt">bool</span> Run(T&amp; x) {
    <span class="kw">if</span> (count_ &gt;= <span class="dv">0</span>) {
      <span class="co">// produce a new value x</span>
      x = SimpleRand(seed_);
      count_--;
      <span class="kw">return</span> <span class="kw">true</span>;
    } <span class="kw">else</span> {
      <span class="kw">return</span> <span class="kw">false</span>;
    }
  }

 <span class="kw">private</span>:
  <span class="dt">int</span> seed_;
  <span class="dt">int</span> count_;
};</code></pre></div>
<p>The class-based approach has several advantages besides the use of templates: Firstly, the creation of multiple processes is straightforward. Secondly, one can derive other processes from a given base class such as <code>Producer</code>. Thirdly, it eases migration of existing code. For example, if you want to use an object of an existing class <code>foo</code> as a process, you might derive a class <code>bar</code> from <code>foo</code> implementing any missing functionality.</p>
<p>To feed our sorting network <code>nw</code> with four streams of integer values, we may write:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Producer&lt;<span class="dt">int</span>&gt;
  producer1(<span class="dv">1</span>),
  producer2(<span class="dv">2</span>),
  producer3(<span class="dv">3</span>),
  producer4(<span class="dv">4</span>);

Network::Source&lt;<span class="dt">int</span>&gt;
  source1(
    network,
    embb::base::MakeFunction(producer1, &amp;Producer&lt;<span class="dt">int</span>&gt;::Run) ),
  source2(
    network,
    embb::base::MakeFunction(producer2, &amp;Producer&lt;<span class="dt">int</span>&gt;::Run) ),
  source3(
    network,
    embb::base::MakeFunction(producer3, &amp;Producer&lt;<span class="dt">int</span>&gt;::Run) ),
  source4(
    network,
    embb::base::MakeFunction(producer4, &amp;Producer&lt;<span class="dt">int</span>&gt;::Run) );</code></pre></div>
<p>The code for the comparators looks like this:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;
<span class="kw">class</span> Comparator {
<span class="kw">public</span>:
  <span class="dt">void</span> Run(<span class="dt">const</span> T&amp; a, <span class="dt">const</span> T&amp; b, T&amp; x, T&amp; y) {
    x = std::min(a,b);
    y = std::max(a,b);
  }
};</code></pre></div>
<p>Since the comparators neither have any side effects nor maintain a state, we allow multiple invocations to be executed in parallel.</p>
<p>To check whether the resulting values are sorted, we use a single sink with four inputs:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;
<span class="kw">class</span> Consumer {
<span class="kw">public</span>:
  <span class="dt">void</span> Run(<span class="dt">const</span> T&amp; x1, <span class="dt">const</span> T&amp; x2, <span class="dt">const</span> T&amp; x3, <span class="dt">const</span> T&amp; x4) {
    <span class="kw">if</span> (x1 &lt;= x2 &amp;&amp; x2 &lt;= x3 &amp;&amp; x3 &lt;= x4) {
      <span class="co">// consume values</span>
    }
  }
};</code></pre></div>
<p>We could also have a sink for each output of the sorting network. There is no restriction on the number of sources and sinks a network may have.</p>
<h2 id="containers"><a name="cha_containers"></a>Containers</h2>
<p>Containers are essential for storing objects in an organized way. Unfortunately, the containers provided by the C++ Standard Library are not thread-safe. Attempts to read and write elements concurrently may corrupt the stored data. While such undefined behavior can be avoided by synchronizing all accesses using a mutex, this largely limits the available parallelism.</p>
<p>The containers provided by EMB² enable a high degree of parallelism by design. They are implemented in a lock-free or wait-free fashion, thus avoiding any blocking operations. This way, multiple threads or tasks may access a container concurrently without suffering from typical side effects like convoying. Wait-free algorithms even guarantee that an operation completes within a bounded number of steps. Consequently, threads are immune to starvation which is critical for real-time systems.</p>
<p>In embedded systems, memory is often preallocated in the initialization phase to minimize the effort for memory management during operation and to prevent unpredictable out-of-memory errors. EMB² containers have a fixed capacity and allocate the required memory at construction time. Consequently, they can be used in safety-critical application, where dynamic memory allocation after initialization is forbidden.</p>
<h3 id="object-pools"><a name="sec_containers_object_pools"></a>Object Pools</h3>
<p>An object pool allocates a fixed number of objects at construction. Objects can then be allocated from the pool and returned for later reuse. When implementing lock-free or wait-free algorithms, the underlying memory allocation scheme also has to be lock-free or wait-free, respectively. However, memory allocation functions such as <code>new</code> and <code>delete</code> usually do not give any progress guarantees. To solve this problem, EMB² provides lock-free and wait-free object pools.</p>
<p><a href="#lst_object_pool_lst1">Listing 2</a> shows an example, where we create a pool containing five objects of type <code>int</code>. As the second step, we allocate five objects from the pool and store the obtained pointers in a temporary array. Finally, we deallocate them by calling <code>Free</code> on each pointer.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">embb::containers::ObjectPool&lt;<span class="dt">int</span>&gt; objPool(<span class="dv">5</span>); <span class="co">// create</span>

<span class="dt">int</span>* alloc[<span class="dv">5</span>];

<span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i != <span class="dv">5</span>; ++i) {
  alloc[i] = objPool.Allocate(); <span class="co">// allocate</span>
}

<span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i != <span class="dv">5</span>; ++i) {
  objPool.Free(alloc[i]); <span class="co">// free</span>
}</code></pre></div>
<p><a name="lst_object_pool_lst1"></a><strong>Listing 2</strong>: Object pool – initialization, allocation, and deallocation</p>
<p>For allocating and deallocating objects, the object pool’s implementation relies on a value pool which keeps track of the objects in use. If the value pool is implemented in a lock-free manner, the object pool is lock-free as well (analogously for wait-free pools). Currently, EMB² provides two value pools: <code>WaitFreeArrayValuePool</code> and <code>LockFreeTreeValuePool</code>. Normally (if nothing else is specified), the wait-free pool is used. For having a lock-free object pool instead, one has to specify the corresponding value pool as additional template parameter. If we replace the first line of the previous example with the following lines, the object pool is not wait-free anymore but lock-free (the values are of type <code>int</code> and initialized with <code>0</code>):</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">embb::containers::ObjectPool&lt;<span class="dt">int</span>, 
  embb::containers::LockFreeTreeValuePool&lt; <span class="dt">int</span>, <span class="dv">0</span> &gt;&gt; objPool(<span class="dv">5</span>);</code></pre></div>
<p>This will result in a speed-up for most applications, but progress guarantees are weaker.</p>
<h3 id="stacks"><a name="sec_containers_stacks"></a>Stacks</h3>
<p>As the name indicates, the class template <code>LockFreeStack</code> implements a lock-free stack which stores elements according to the LIFO (Last-In, First-Out) principle. The stack provides two methods, <code>TryPush</code> and <code>TryPop</code>, both returning a Boolean value indicating success of the operation: <code>TryPop</code> returns <code>false</code> if the stack is empty, and <code>TryPush</code> returns <code>false</code> if the stack is full. If successful, <code>TryPop</code> returns the element removed from the stack via reference. <a href="#lst_stack_lst1">Listing 3</a> shows a simple example. First, we create a stack of integers with a capacity of 10 elements (due to necessary over-provisioning of memory in thread-safe memory management, the stack might be able to hold more than 10 elements, but is guaranteed to be able to hold at least 10 elements). Then, we try to pop an element from the empty stack, which has to fail. In the subsequent for-loop, we fill the stack with the values 0...4. Afterwards, we pop five values from the stack into variable <code>j</code>. According to the LIFO semantics, the values are popped in reverse order, i.e., we get the sequence 4...0, which is checked by the assertion.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">embb::containers::LockFreeStack&lt;<span class="dt">int</span>&gt; stack(<span class="dv">10</span>); <span class="co">// create</span>

<span class="dt">int</span> i, j;
<span class="dt">bool</span> result = stack.TryPop(i); <span class="co">// fail_pop</span>
assert(result == <span class="kw">false</span>);

<span class="kw">for</span> (i = <span class="dv">0</span>; i &lt;= <span class="dv">4</span>; ++i) { <span class="co">// loop1</span>
  result = stack.TryPush(i); <span class="co">// push</span>
  assert(result == <span class="kw">true</span>);
}

<span class="kw">for</span> (i = <span class="dv">4</span>; i &gt;= <span class="dv">0</span>; --i) { <span class="co">// loop2</span>
  result = stack.TryPop(j); <span class="co">// pop</span>
  assert(result == <span class="kw">true</span> &amp;&amp; i == j); <span class="co">// assert</span>
}</code></pre></div>
<p><a name="lst_stack_lst1"></a><strong>Listing 3</strong>: Stack - initialization, push, and pop</p>
<h3 id="queues"><a name="sec_containers_queues"></a>Queues</h3>
<p>There are currently two FIFO (First-In, First-Out) queue implementations in EMB², <code>LockFreeMPMCQueue</code> and <code>WaitFreeSPSCQueue</code>. The former can deal with multiple producers and multiple consumers (MPMC), whereas the latter is restricted to a single producer and a single consumer (SPSC). The interfaces are the same for both queues. The Boolean return value of the methods <code>TryEnqueue</code> and <code>TryDequeue</code> indicates success (<code>false</code> if the queue is full or empty, respectively).</p>
<p><a href="#lst_queue_lst1">Listing 4</a> shows an example for the <code>LockFreeMPMCQueue</code>. First, we create a queue with element type <code>int</code> and a capacity of (at least) 10 elements. Then, we try to dequeue an element from the empty queue, which has to fail. In the subsequent for-loop, we fill the queue with the values 0...4. Afterwards, we dequeue five values from the queue into variable <code>j</code>. According to the FIFO semantics, the values are dequeued in the same order as they were enqueued, i.e., we get the sequence 0...4, which is checked by the assertion.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">embb::containers::LockFreeMPMCQueue&lt;<span class="dt">int</span>&gt; queue(<span class="dv">10</span>); <span class="co">// create</span>

<span class="dt">int</span> i, j;
<span class="dt">bool</span> result = queue.TryDequeue(i); <span class="co">// fail_pop</span>
assert(result == <span class="kw">false</span>);

<span class="kw">for</span> (i = <span class="dv">0</span>; i &lt;= <span class="dv">4</span>; ++i) { <span class="co">// loop1</span>
  result = queue.TryEnqueue(i); <span class="co">// push</span>
  assert(result == <span class="kw">true</span>);
}

<span class="kw">for</span> (i = <span class="dv">0</span>; i &lt;= <span class="dv">4</span>; ++i) { <span class="co">// loop2</span>
  result = queue.TryDequeue(j); <span class="co">// pop</span>
  assert(result == <span class="kw">true</span> &amp;&amp; i == j); <span class="co">// assert</span>
}</code></pre></div>
<p><a name="lst_queue_lst1"></a><strong>Listing 4</strong>: Queue – initialization, enqueue, and dequeue</p>
<h2 id="mtapi"><a name="cha_mtapi"></a>MTAPI</h2>
<p>Leveraging the power of multicore processors requires to split computations into fine-grained tasks that can be executed in parallel. Threads are usually too heavy-weight for that purpose, since context switches consume a significant amount of time. Moreover, programming with threads is complex and error-prone due to typical pitfalls such as race conditions and deadlocks. To solve these problems, efficient task scheduling techniques have been developed which dynamically distribute the available tasks among a fixed number of worker threads. To reduce overhead, there is usually exactly one worker thread for each processor core.</p>
<p>While task schedulers are nowadays widely employed, especially in desktop and server applications, they are typically limited to a single operating system running on a homogeneous multicore processor. System-wide task management in heterogeneous embedded systems must be realized explicitly with low-level communication mechanisms. MTAPI <a href="#bib_mtapi">[1]</a> addresses those issues by providing an API which allows parallel embedded software to be designed in a straightforward way, covering homogeneous and heterogeneous multicore architectures, as well as accelerators such as GPUs or FPGAs. As a major advantage, it abstracts from the hardware details and lets software developers focus on the application. Moreover, MTAPI takes into account typical requirements of embedded systems such as real-time constraints and predictable memory consumption.</p>
<p>The remainder of this chapter is structured as follows: The next section explains the basic terms and concepts of MTAPI as given in the specification <a href="#bib_mtapi">[1]</a>. The section on the <a href="#sec_mtapi_c_interface">MTAPI C Interface</a> describes the C API using a simple example taken from <a href="#bib_mtapi">[1]</a>. Finally, the section on the <a href="#sec_mtapi_cpp_interface">MTAPI C++ Interface</a> outlines the use of MTAPI in C++ applications. Note that the C++ interface is provided by EMB² for convenience but it is not part of the standard. Readers who are familiar with MTAPI or just want to get impression on how to use MTAPI in heterogeneous systems may skip this chapter on go directly to <a href="#cha_heterogeneous_systems">Heterogeneous Systems</a> or the <a href="#cha_tutorial_application">Tutorial Application</a>.</p>
<h3 id="foundations"><a name="sec_mtapi_foundations"></a>Foundations</h3>
<h4 id="domains">Domains</h4>
<p>An MTAPI system is composed of one or more MTAPI domains. An MTAPI domain is a unique system global entity. Each MTAPI domain comprises a set of MTAPI nodes. An MTAPI node may only belong to one MTAPI domain, while an MTAPI domain may contain one or more MTAPI nodes. This allows the programmer to use MTAPI domains as namespaces for all kinds of IDs (e.g., nodes, actions, queues, etc.).</p>
<h4 id="nodes">Nodes</h4>
<p>An MTAPI node is an independent unit of execution, such as a process, thread, thread pool, processor, hardware accelerator, or instance of an operating system. A given MTAPI implementation specifies what constitutes a node for that implementation.</p>
<p>The intent is to avoid a mixture of node definitions in the same implementation (or in different domains within an implementation). If a node is defined as a unit of execution with its private address space (like a process), then a core with a single unprotected address space OS is equivalent to a node, whereas a core with a virtual memory OS can host multiple nodes.</p>
<p>On a shared memory SMP processor, a node can be defined as a subset of cores. A quad-core processor, for example, could be divided into two nodes, one node representing three cores and one node representing the fourth core reserved exclusively for certain tasks. The definition of a node is flexible because this allows applications to be written in the most portable fashion supported by the underlying hardware, while at the same time supporting more general-purpose multicore and many-core devices.</p>
<p>The definition allows portability of software at the interface level (e.g., the functional interface between nodes). However, the software implementation of a particular node cannot (and often should not) necessarily be preserved across a multicore SoC product line (or across product lines from different silicon providers) because a given node’s functionality may be provided in different ways, depending on the chosen multicore SoC.</p>
<h4 id="tasks">Tasks</h4>
<p>A task represents the computation associated with the data to be processed and is executed concurrently to the code starting it. The main API functions are <code>mtapi_task_start()</code> and <code>mtapi_task_wait()</code>. The semantics are similar to the corresponding thread functions (e.g., <code>pthread_create</code> / <code>pthread_join</code> in POSIX Threads). The lifetime of a task is limited; it can be started only once.</p>
<h4 id="actions">Actions</h4>
<p>In order to cope with heterogeneous systems and computations implemented in hardware, a task is not directly associated with an entry function as it is done in other task-parallel APIs. Instead, it is associated with at least one action object representing the calculation. The association is indirect: one or more actions implement a job, one job is associated with a task. If the action is implemented in software, this is either a function on the same node (which can represent the same processor or core) or a function implemented on a different node that does not share memory with the core starting the task.</p>
<p>Starting a task consists of three steps:</p>
<ol style="list-style-type: decimal">
<li>Create the action object with a job ID (software-implemented actions only).</li>
<li>Obtain a job reference.</li>
<li>Start the task using the job reference.</li>
</ol>
<h4 id="synchronization">Synchronization</h4>
<p>The basic synchronization mechanism provided by MTAPI is waiting for task completion. Calling <code>mtapi_task_wait()</code> with a task handle blocks the current thread or task until the task referenced by the handle has completed. Depending on the implementation, the calling thread can be used for executing other tasks while waiting for the task to be completed. In order to synchronize with a set of tasks, every task can be associated with a task group. The methods <code>mtapi_group_wait_all()</code> and <code>mtapi_group_wait_any()</code> wait for a group of tasks or completion of any task in the group, respectively.</p>
<h4 id="queues-1">Queues</h4>
<p>Queues are used for guaranteeing sequential order of execution of tasks. A common use case is packet processing in the communication domain: for every connection all packets must be processed sequentially, while the packets of different connections can be processed in parallel to each other.</p>
<p>Sequential execution is accomplished by using a queue for every connection and queuing all packets of one connection into the same queue. In some systems, queues are implemented in hardware, otherwise MTAPI implements software queues. MTAPI is designed for handling thousands of queues that are processed in parallel.</p>
<p>The procedure for setting up and using a queue is as follows:</p>
<ol style="list-style-type: decimal">
<li>Create the action object (software-implemented actions only).</li>
<li>Obtain a job reference.</li>
<li>Create a queue object and attach the job to the queue (software-implemented queues only).</li>
<li>Obtain a queue handle if the queue was created on a different node, or if the queue is hardware-implemented.</li>
<li>Use the queue: enqueue the work using the queue.</li>
</ol>
<p>Another important purpose of queues is that different queues can express different scheduling attributes for the same job. For example, in contrast to order-preserving queues, non-order-preserving queues can be used for load-balancing purposes between different computation nodes. In this case, the queue must be associated with more than one action implementing the same task on different nodes (i.e., different processors or cores implementing different instruction set architectures). If a queue is configured this way, the order will not be preserved.</p>
<h4 id="attributes">Attributes</h4>
<p>Attributes are provided as a means to extend the API. Different implementations may define and support additional attributes beyond those predefined by the API. To foster portability and implementation flexibility, attributes are maintained in an opaque data object that may not be examined directly by the user. Each object (e.g., task, action, queue) has an attributes data object associated with it, and many attributes have a small set of predefined values that must be supported by MTAPI implementations. The user may initialize, get, and set these attributes. For default behavior, it is not necessary to call the initialize, get, and set attribute functions. However, to get non-default behavior, the typical four-step process is:</p>
<ol style="list-style-type: decimal">
<li>Declare an attributes object of the <code>mtapi_&lt;object&gt;_attributes_t</code> data type.</li>
<li><code>mtapi_&lt;object&gt;attr_init()</code>: Returns an attributes object with all attributes set to their default values.</li>
<li><code>mtapi_&lt;object&gt;attr_set()</code> (Repeat for all attributes to be set): Assigns a value to the specified attribute of the specified attributes object.</li>
<li><code>mtapi_&lt;object&gt;_create()</code>: Passes the attributes object modified in the previous step as a parameter when creating the object.</li>
</ol>
<p>At any time, the user can call <code>mtapi_&lt;object&gt;_get_attribute()</code> to query the value of an attribute. After an object has been created, some objects allow to change attributes by calling <code>mtapi_&lt;object&gt;_set_attribute()</code>.</p>
<h3 id="c-interface"><a name="sec_mtapi_c_interface"></a>C Interface</h3>
<p>The calculation of Fibonacci numbers is a simple example for a recursive algorithm that can easily be parallelized. <a href="#lst_mtapi_fibonacci_sequential">Listing 5</a> shows a sequential version:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> fib(<span class="dt">int</span> n) {
  <span class="dt">int</span> x,y;
  <span class="kw">if</span> (n &lt; <span class="dv">2</span>) {
    <span class="kw">return</span> n;
  } <span class="kw">else</span> {
    x = fib(n - <span class="dv">1</span>);
    y = fib(n - <span class="dv">2</span>);
    <span class="kw">return</span> x + y;
  }
}

<span class="dt">int</span> fibonacci(<span class="dt">int</span> n) {
  <span class="kw">return</span> fib(n);
}

<span class="dt">void</span> main(<span class="dt">void</span>) {
  <span class="dt">int</span> n = <span class="dv">6</span>;
  <span class="dt">int</span> result = fibonacci(n);
  printf(<span class="st">&quot;fib(</span><span class="ch">%i</span><span class="st">) = </span><span class="ch">%i\n</span><span class="st">&quot;</span>, n, result);
}</code></pre></div>
<p><a name="lst_mtapi_fibonacci_sequential"></a><strong>Listing 5</strong>: Sequential program for computing Fibonacci numbers</p>
<p>This algorithm can be parallelized by spawning a task for one of the recursive calls (<code>fib(n - 1)</code>, for example). When doing this with MTAPI, an action function that represents <code>fib(int n)</code> is needed. It has the following signature:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> fibonacciActionFunction(
  <span class="dt">const</span> <span class="dt">void</span>* args,
  mtapi_size_t arg_size,
  <span class="dt">void</span>* result_buffer,
  mtapi_size_t result_buffer_size,
  <span class="dt">const</span> <span class="dt">void</span>* <span class="co">/*node_local_data*/</span>,
  mtapi_size_t <span class="co">/*node_local_data_size*/</span>,
  mtapi_task_context_t* task_context
  ) {</code></pre></div>
<p>Within the action function, the arguments should be checked, since the user might supply a buffer that is too small:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/* check size of arguments (in this case we only expect one int</span>
<span class="co">   value) */</span>
mtapi_status_t status;
<span class="kw">if</span> (arg_size != <span class="kw">sizeof</span>(<span class="dt">int</span>)) {
  printf(<span class="st">&quot;wrong size of arguments</span><span class="ch">\n</span><span class="st">&quot;</span>);
  mtapi_context_status_set(task_context, MTAPI_ERR_ARG_SIZE,
                           &amp;status);
  MTAPI_CHECK_STATUS(status);
  <span class="kw">return</span>;
}

<span class="co">/* cast arguments to the desired type */</span>
<span class="dt">int</span> n = *(<span class="dt">int</span>*)args;</code></pre></div>
<p>Here, <code>mtapi_context_status_set()</code> is used to report errors. The error code will be returned by <code>mtapi_task_wait()</code>. Also, care has to be taken when using the result buffer. The user might not want to use the result and supply a <code>NULL</code> pointer or accidentally a buffer that is too small:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/* if the caller is not interested in results, result_buffer may be</span>
<span class="co">   MTAPI_NULL. Of course, this depends on the application */</span>
<span class="dt">int</span>* result = MTAPI_NULL;
<span class="kw">if</span> (result_buffer == MTAPI_NULL) {
  mtapi_context_status_set(
    task_context, MTAPI_ERR_RESULT_SIZE, &amp;status);
  MTAPI_CHECK_STATUS(status);
} <span class="kw">else</span> {
  <span class="co">/* if results are expected by the caller, check result buffer</span>
<span class="co">     size... */</span>
  <span class="kw">if</span> (result_buffer_size == <span class="kw">sizeof</span>(<span class="dt">int</span>)) {
    <span class="co">/* ... and cast the result buffer */</span>
    result = (<span class="dt">int</span>*)result_buffer;
  } <span class="kw">else</span> {
    printf(<span class="st">&quot;wrong size of result buffer</span><span class="ch">\n</span><span class="st">&quot;</span>);
    mtapi_context_status_set(
      task_context, MTAPI_ERR_RESULT_SIZE, &amp;status);
    MTAPI_CHECK_STATUS(status);
    <span class="kw">return</span>;
  }
}</code></pre></div>
<p>At this point, calculation of the result can commence. First, the terminating condition of the recursion is checked:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">if</span> (n &lt; <span class="dv">2</span>) {
  *result = n;
} <span class="kw">else</span> {</code></pre></div>
<p>After that, the first part of the computation is launched as a task using <code>mtapi_task_start()</code> (the action function is registered with the job <code>FIBONACCI_JOB</code> in the <code>fibonacci()</code> function and the resulting handle is stored in the global variable <code>mtapi_job_hndl_t fibonacciJob</code>):</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> a = n - <span class="dv">1</span>;
<span class="dt">int</span> x;
mtapi_task_hndl_t task = mtapi_task_start(
  MTAPI_TASK_ID_NONE,              <span class="co">/* optional task ID */</span>
  fibonacciJob,                    <span class="co">/* job */</span>
  (<span class="dt">void</span>*)&amp;a,                       <span class="co">/* arguments passed to action</span>
<span class="co">                                      functions */</span>
  <span class="kw">sizeof</span>(<span class="dt">int</span>),                     <span class="co">/* size of arguments */</span>
  (<span class="dt">void</span>*)&amp;x,                       <span class="co">/* result buffer */</span>
  <span class="kw">sizeof</span>(<span class="dt">int</span>),                     <span class="co">/* size of result buffer */</span>
  MTAPI_DEFAULT_TASK_ATTRIBUTES,   <span class="co">/* task attributes */</span>
  MTAPI_GROUP_NONE,                <span class="co">/* optional task group */</span>
  &amp;status                          <span class="co">/* status out - parameter */</span>
);
MTAPI_CHECK_STATUS(status);</code></pre></div>
<p>The second part can be executed directly:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> b = n - <span class="dv">2</span>;
<span class="dt">int</span> y;
fibonacciActionFunction(
  &amp;b, <span class="kw">sizeof</span>(<span class="dt">int</span>),
  &amp;y, <span class="kw">sizeof</span>(<span class="dt">int</span>),
  MTAPI_NULL, <span class="dv">0</span>,
  task_context);</code></pre></div>
<p>Then, completion of the MTAPI task has to be waited for by calling <code>mtapi_task_wait()</code>:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">mtapi_task_wait(task, MTAPI_INFINITE, &amp;status);</code></pre></div>
<p>Finally, the results can be added and written into the result buffer:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">*result = x + y;</code></pre></div>
<p>The <code>fibonacci()</code> function gets a bit more complicated now. The MTAPI runtime has to be initialized first by (optionally) initializing node attributes and then calling <code>mtapi_initialize()</code>:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">mtapi_status_t status;

<span class="co">/* initialize node attributes to default values */</span>
mtapi_node_attributes_t node_attr;
mtapi_nodeattr_init(&amp;node_attr, &amp;status);
MTAPI_CHECK_STATUS(status);

<span class="co">/* set node type to SMP */</span>
mtapi_nodeattr_set(
  &amp;node_attr,
  MTAPI_NODE_TYPE,
  MTAPI_ATTRIBUTE_VALUE(MTAPI_NODE_TYPE_SMP),
  MTAPI_ATTRIBUTE_POINTER_AS_VALUE,
  &amp;status);
MTAPI_CHECK_STATUS(status);

<span class="co">/* initialize the node */</span>
mtapi_info_t info;
mtapi_initialize(
  THIS_DOMAIN_ID,
  THIS_NODE_ID,
  &amp;node_attr,
  &amp;info,
  &amp;status);
MTAPI_CHECK_STATUS(status);</code></pre></div>
<p>Then, the action function needs to be associated to a job. By calling <code>mtapi_action_create()</code>, the action function is registered with the job <code>FIBONACCI_JOB</code>. The job handle of this job is stored in the global variable <code>mtapi_job_hndl_t fibonacciJob</code> so that it can be accessed by the action function later on:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/* create action */</span>
mtapi_action_hndl_t fibonacciAction;
fibonacciAction = mtapi_action_create(
  FIBONACCI_JOB,                     <span class="co">/* action ID, defined by the</span>
<span class="co">                                        application */</span>
  (fibonacciActionFunction),         <span class="co">/* action function */</span>
  MTAPI_NULL,                        <span class="co">/* no shared data */</span>
  <span class="dv">0</span>,                                 <span class="co">/* length of shared data */</span>
  MTAPI_DEFAULT_ACTION_ATTRIBUTES,   <span class="co">/* action attributes */</span>
  &amp;status                            <span class="co">/* status out - parameter */</span>
);
MTAPI_CHECK_STATUS(status);

<span class="co">/* get job */</span>
mtapi_task_hndl_t task;
fibonacciJob = mtapi_job_get(FIBONACCI_JOB, THIS_DOMAIN_ID, &amp;status);
MTAPI_CHECK_STATUS(status);</code></pre></div>
<p>Now that the action is registered with a job, the root task can be started with <code>mtapi_task_start()</code>:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/* start task */</span>
<span class="dt">int</span> result;
task = mtapi_task_start(
  MTAPI_TASK_ID_NONE,                <span class="co">/* optional task ID */</span>
  fibonacciJob,                      <span class="co">/* job */</span>
  (<span class="dt">void</span>*)&amp;n,                         <span class="co">/* arguments passed to action</span>
<span class="co">                                        functions */</span>
  <span class="kw">sizeof</span>(<span class="dt">int</span>),                       <span class="co">/* size of arguments */</span>
  (<span class="dt">void</span>*)&amp;result,                    <span class="co">/* result buffer */</span>
  <span class="kw">sizeof</span>(<span class="dt">int</span>),                       <span class="co">/* size of result buffer */</span>
  MTAPI_DEFAULT_TASK_ATTRIBUTES,     <span class="co">/* task attributes */</span>
  MTAPI_GROUP_NONE,                  <span class="co">/* optional task group */</span>
  &amp;status                            <span class="co">/* status out - parameter */</span>
);
MTAPI_CHECK_STATUS(status);</code></pre></div>
<p>After everything is done, the action is deleted (<code>mtapi_action_delete()</code>) and the runtime is shut down (<code>mtapi_finalize()</code>):</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/* delete action */</span>
mtapi_action_delete(fibonacciAction, <span class="dv">100</span>, &amp;status);
MTAPI_CHECK_STATUS(status);

<span class="co">/* finalize the node */</span>
mtapi_finalize(&amp;status);
MTAPI_CHECK_STATUS(status);</code></pre></div>
<h3 id="c-interface-1"><a name="sec_mtapi_cpp_interface"></a>C++ Interface</h3>
<p>As mentioned previously, EMB² provides C++ wrappers for the MTAPI C interface. The full interface provides functions for all MTAPI related tasks and even supports heterogeneous systems. For ease of use, a simpler version for SMP systems is also provided.</p>
<h4 id="full-interface">Full Interface</h4>
<p>The signature of an action function for the C++ interface is the same as for the C interface:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> fibonacciActionFunction(
  <span class="dt">const</span> <span class="dt">void</span>* args,
  mtapi_size_t arg_size,
  <span class="dt">void</span>* result_buffer,
  mtapi_size_t result_buffer_size,
  <span class="dt">const</span> <span class="dt">void</span>* <span class="co">/*node_local_data*/</span>,
  mtapi_size_t <span class="co">/*node_local_data_size*/</span>,
  mtapi_task_context_t* task_context
  ) {</code></pre></div>
<p>Checking argument and result buffer sizes is the same as in the C example. Also, the terminating condition of the recursion still needs to be checked:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">if</span> (n &lt; <span class="dv">2</span>) {
  *result = n;
} <span class="kw">else</span> {</code></pre></div>
<p>After that, the first part of the computation is launched as an MTAPI task using <code>embb::mtapi::Node::Start()</code> (the action function is registered with the job <code>FIBONACCI_JOB</code> in the <code>fibonacci()</code> function and the resulting handle is stored in the global variable <code>embb::mtapi::Job fibonacciJob</code>):</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> a = n - <span class="dv">1</span>;
<span class="dt">int</span> x;
embb::mtapi::Task task = node.Start(fibonacciJob, &amp;a, &amp;x);</code></pre></div>
<p>The second part can be executed directly:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> b = n - <span class="dv">2</span>;
<span class="dt">int</span> y;
fibonacciActionFunction(
  &amp;b, <span class="kw">sizeof</span>(<span class="dt">int</span>),
  &amp;y, <span class="kw">sizeof</span>(<span class="dt">int</span>),
  MTAPI_NULL, <span class="dv">0</span>,
  task_context);</code></pre></div>
<p>Then, completion of the MTAPI task has to be waited for using <code>embb::mtapi::Task::Wait()</code>:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">mtapi_status_t task_status = task.Wait(MTAPI_INFINITE);
<span class="kw">if</span> (task_status != MTAPI_SUCCESS) {
  printf(<span class="st">&quot;task failed with error: </span><span class="ch">%d\n\n</span><span class="st">&quot;</span>, task_status);
  exit(task_status);
}</code></pre></div>
<p>Finally, the two parts can be added and written into the result buffer:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">*result = x + y;</code></pre></div>
<p>Note that there is no need to do error checking everywhere, since errors are reported as exceptions. In this example there is only a single try/catch block in the main function:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">EMBB_TRY {
  <span class="dt">int</span> result = fibonacci(<span class="dv">6</span>);
  std::cout &lt;&lt; <span class="st">&quot;result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;
} EMBB_CATCH(embb::mtapi::StatusException &amp;) {
  std::cout &lt;&lt; <span class="st">&quot;MTAPI error occured.&quot;</span> &lt;&lt; std::endl;
}</code></pre></div>
<p>The <code>fibonacci()</code> function is about the same as in the C version. The MTAPI runtime needs to be initialized first:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/* initialize the node with default attributes */</span>
embb::mtapi::Node::Initialize(THIS_DOMAIN_ID, THIS_NODE_ID);</code></pre></div>
<p>Then, the node instance can be fetched:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">embb::mtapi::Node&amp; node = embb::mtapi::Node::GetInstance();</code></pre></div>
<p>After that, the action function needs to be associated to a job. By instantiating an <code>embb::mtap::Action</code> object, the action function is registered with the job <code>FIBONACCI_JOB</code>. The job is stored in the global variable <code>embb::mtapi::Job fibonacciJob</code> so that it can be accessed by the action function later on:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/* create action */</span>
embb::mtapi::Action fibonacciAction = node.CreateAction(
  FIBONACCI_JOB,                     <span class="co">/* action ID, defined by the</span>
<span class="co">                                        application */</span>
  (fibonacciActionFunction)          <span class="co">/* action function */</span>
);

<span class="co">/* get job */</span>
fibonacciJob = node.GetJob(FIBONACCI_JOB, THIS_DOMAIN_ID);</code></pre></div>
<p>Now that the action is registered and the job is initialized, the root task can be started:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> result;
embb::mtapi::Task task = node.Start(fibonacciJob, &amp;n, &amp;result);</code></pre></div>
<p>Again, the started task has to be waited for (using <code>embb::mtapi::Task::Wait()</code>) before the result can be returned.</p>
<p>The registered action will be unregistered when it goes out of scope. The runtime needs to be shut down by calling:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">embb::mtapi::Node::Finalize();</code></pre></div>
<h4 id="simplified-interface-for-smp-actions">Simplified Interface for SMP actions</h4>
<p>The signature of an action function for the simplified API (SMP systems) looks like this:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> simpleActionFunction(
  TaskContext &amp; task_context
) {
  <span class="co">// something useful</span>
}</code></pre></div>
<p>The action function does not need to be registered with a job. Instead, a preregistered job is used that expects an <code>embb::base::Function&lt;void, embb::mtapi::TaskContext &amp;&gt;</code> object. Therefore, a task can be scheduled directly using only the function above:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">embb::mtapi::Task task = node.Start(simpleActionFunction);</code></pre></div>
<h3 id="plugins"><a name="sec_mtapi_plugins"></a>Plugins</h3>
<p>The implementation of MTAPI provides an extension to allow for custom actions that are not executed by the scheduler for software actions as described in the previous sections. Three plugins are delivered with EMB², one for supporting distributed systems through TCP/IP networking and the other two for OpenCL or CUDA-capable GPUs.</p>
<h4 id="plugin-api">Plugin API</h4>
<p>The plugin API essentially consists of a single function contained in the <code>mtapi_ext.h</code> header file:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">mtapi_ext_plugin_action_create()</code></pre></div>
<p>This function is used to associate the plugin action with a specific job ID:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">mtapi_action_hndl_t mtapi_ext_plugin_action_create(
  MTAPI_IN mtapi_job_id_t job_id,
  MTAPI_IN mtapi_ext_plugin_task_start_function_t task_start_function,
  MTAPI_IN mtapi_ext_plugin_task_cancel_function_t task_cancel_function,
  MTAPI_IN mtapi_ext_plugin_action_finalize_function_t action_finalize_function,
  MTAPI_IN <span class="dt">void</span>* plugin_data,
  MTAPI_IN <span class="dt">void</span>* node_local_data,
  MTAPI_IN mtapi_size_t node_local_data_size,
  MTAPI_IN mtapi_action_attributes_t* attributes,
  MTAPI_OUT mtapi_status_t* status
);</code></pre></div>
<p>The plugin action is implemented through three callbacks: task start, task cancel, and action finalize.</p>
<p><code>task_start_function</code> is called when the user requests execution of the plugin action by calling <code>mtapi_task_start()</code> or <code>mtapi_task_enqueue()</code>. To those functions the fact that they operate on a plugin action is transparent, they only require the handle of the job the action was registered with.</p>
<p><code>task_cancel_function</code> is called when the user requests cancelation of a task by calling <code>mtapi_task_cancel()</code> or by calling <code>mtapi_queue_disable()</code> on a non-retaining queue.</p>
<p><code>action_finalize_function</code> is called when the node is finalized and the action is deleted, or when the user explicitly deletes the action by calling <code>mtapi_action_delete()</code>.</p>
<p>For illustration, our example plugin will provide a no-op action. The task start callback in that case looks like this:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> plugin_task_start(
  MTAPI_IN mtapi_task_hndl_t task,
  MTAPI_OUT mtapi_status_t* status) {
  mtapi_status_t local_status = MTAPI_ERR_UNKNOWN;

  <span class="co">// do we have a node?</span>
  <span class="kw">if</span> (embb_mtapi_node_is_initialized()) {
    <span class="co">// get the node instance</span>
    embb_mtapi_node_t * node = embb_mtapi_node_get_instance();

    <span class="co">// is this a valid task?</span>
    <span class="kw">if</span> (embb_mtapi_task_pool_is_handle_valid(node-&gt;task_pool, task)) {
      <span class="co">// get the tasks storage</span>
      embb_mtapi_task_t * local_task =
        embb_mtapi_task_pool_get_storage_for_handle(node-&gt;task_pool, task);

      <span class="co">// dispatch the task</span>
      plugin_task_schedule(local_task);

      local_status = MTAPI_SUCCESS;
    }
    <span class="kw">else</span> {
      local_status = MTAPI_ERR_TASK_INVALID;
    }
  }
  <span class="kw">else</span> {
    local_status = MTAPI_ERR_NODE_NOTINIT;
  }

  mtapi_status_set(status, local_status);
}</code></pre></div>
<p>The scheduling operation is responsible for bringing the task to execution. This might involve instructing some hardware to execute the task or pushing the task into a queue for execution by a separate worker thread. Here, however, the task is executed directly:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> plugin_task_schedule(embb_mtapi_task_t* local_task) {
  <span class="co">// here the task might be dispatched to some hardware or separate thread</span>

  <span class="co">// mark the task as running</span>
  embb_mtapi_task_set_state(local_task, MTAPI_TASK_RUNNING);

  <span class="co">// nothing to do to execute the no-op task</span>

  <span class="co">// just mark the task as done</span>
  embb_mtapi_task_set_state(local_task, MTAPI_TASK_COMPLETED);
}</code></pre></div>
<p>Since the task gets executed right away, it cannot be canceled and the task cancel callback implementation is empty:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> plugin_task_cancel(
  MTAPI_IN mtapi_task_hndl_t task,
  MTAPI_OUT mtapi_status_t* status
  ) {
  EMBB_UNUSED(task);
  <span class="co">// nothing to cancel in this simple example</span>
  mtapi_status_set(status, MTAPI_SUCCESS);
}</code></pre></div>
<p>The plugin action did not acquire any resources, so the action finalize callback is empty as well:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> plugin_action_finalize(
  MTAPI_IN mtapi_action_hndl_t action,
  MTAPI_OUT mtapi_status_t* status
  ) {
  EMBB_UNUSED(action);
  <span class="co">// nothing to do for tearing down the plugin action</span>
  mtapi_status_set(status, MTAPI_SUCCESS);
}</code></pre></div>
<p>Now that the callbacks are in place, the action can be registered with a job after the node was initialized using <code>mtapi_initialize()</code>:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">action = mtapi_ext_plugin_action_create(
  PLUGIN_JOB_ID,
  plugin_task_start,
  plugin_task_cancel,
  plugin_action_finalize,
  MTAPI_NULL,
  MTAPI_NULL,
  <span class="dv">0</span>,
  MTAPI_DEFAULT_ACTION_ATTRIBUTES,
  &amp;status);</code></pre></div>
<p>The job handle can now be obtained the normal MTAPI way. The fact that there is a plugin working behind the scenes is transparent:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">job = mtapi_job_get(
  PLUGIN_JOB_ID,
  PLUGIN_DOMAIN_ID,
  &amp;status);</code></pre></div>
<p>Using the job handle, tasks can be started like normal MTAPI tasks:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">task = mtapi_task_start(
  MTAPI_TASK_ID_NONE,
  job,
  MTAPI_NULL, <span class="dv">0</span>,
  MTAPI_NULL, <span class="dv">0</span>,
  MTAPI_DEFAULT_TASK_ATTRIBUTES,
  MTAPI_GROUP_NONE,
  &amp;status);</code></pre></div>
<p>This call will lead to the invocation of the <code>plugin_task_start</code> callback function, where the plugin implementer is responsible for bringing the task to execution.</p>
<h4 id="network">Network</h4>
<p>The MTAPI network plugin provides a means to distribute tasks over a TCP/IP network. As an example, the following vector addition action is used:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> AddVectorAction(
  <span class="dt">void</span> <span class="dt">const</span> * arguments,
  mtapi_size_t arguments_size,
  <span class="dt">void</span> * result_buffer,
  mtapi_size_t result_buffer_size,
  <span class="dt">void</span> <span class="dt">const</span> * node_local_data,
  mtapi_size_t node_local_data_size,
  mtapi_task_context_t * context) {
  EMBB_UNUSED(context);
  EMBB_UNUSED(result_buffer_size);
  EMBB_UNUSED(node_local_data_size);
  <span class="dt">int</span> elements = <span class="kw">static_cast</span>&lt;<span class="dt">int</span>&gt;(arguments_size / <span class="kw">sizeof</span>(<span class="dt">float</span>) / <span class="dv">2</span>);
  <span class="dt">float</span> <span class="dt">const</span> * a = <span class="kw">reinterpret_cast</span>&lt;<span class="dt">float</span> <span class="dt">const</span> *&gt;(arguments);
  <span class="dt">float</span> <span class="dt">const</span> * b = <span class="kw">reinterpret_cast</span>&lt;<span class="dt">float</span> <span class="dt">const</span> *&gt;(arguments)+elements;
  <span class="dt">float</span> * c = <span class="kw">reinterpret_cast</span>&lt;<span class="dt">float</span>*&gt;(result_buffer);
  <span class="dt">float</span> <span class="dt">const</span> * d = <span class="kw">reinterpret_cast</span>&lt;<span class="dt">float</span> <span class="dt">const</span> *&gt;(node_local_data);
  <span class="kw">for</span> (<span class="dt">int</span> ii = <span class="dv">0</span>; ii &lt; elements; ii++) {
    c[ii] = a[ii] + b[ii] + d[<span class="dv">0</span>];
  }
}</code></pre></div>
<p>It adds two float vectors and a float from node local data, and writes the result into the result float vector. In the example, code the vectors will hold <code>kElements</code> floats each.</p>
<p>To use the network plugin, its header file needs to be included first:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embb/mtapi/c/mtapi_network.h&gt;</span></code></pre></div>
<p>After initializing the node using <code>mtapi_initialize()</code>, the plugin itself needs to be initialized:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">mtapi_network_plugin_initialize(<span class="st">&quot;127.0.0.1&quot;</span>, <span class="dv">12345</span>, <span class="dv">5</span>,
  kElements * <span class="dv">4</span> * <span class="dv">3</span> + <span class="dv">32</span>, &amp;status);</code></pre></div>
<p>This will set up a listening socket on the localhost interface (127.0.0.1) at port 12345. The socket will allow a maximum of five connections and has a maximum transfer buffer size of <code>kElements * 4 * 3 + 32</code>. This buffer size needs to be large enough to fit at least the argument and result buffer sizes at once. The example uses three vectors of <code>kElements</code> floats using <code>kElements * sizeof(float) * 3</code> bytes.</p>
<p>Since the example connects to itself on localhost, the “remote” action needs to be registered with the <code>NETWORK_REMOTE_JOB</code>:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">float</span> node_remote = <span class="fl">1.0f</span>;
local_action = mtapi_action_create(
  NETWORK_REMOTE_JOB,
  AddVectorAction,
  &amp;node_remote, <span class="kw">sizeof</span>(<span class="dt">float</span>),
  MTAPI_DEFAULT_ACTION_ATTRIBUTES,
  &amp;status);</code></pre></div>
<p>After that, the local network action is created that maps <code>NETWORK_LOCAL_JOB</code> to <code>NETWORK_REMOTE_JOB</code> through the network:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">network_action = mtapi_network_action_create(
  NETWORK_DOMAIN,
  NETWORK_LOCAL_JOB,
  NETWORK_REMOTE_JOB,
  <span class="st">&quot;127.0.0.1&quot;</span>, <span class="dv">12345</span>,
  &amp;status);</code></pre></div>
<p>Now, <code>NETWORK_LOCAL_JOB</code> can be used to execute tasks by simply calling <code>mtapi_task_start()</code>. Their parameters will be transmitted through a socket connection and are consumed by the network plugin worker thread. The thread will start a task using the <code>NETWORK_REMOTE_JOB</code>. When this task is finished, the results will be collected and sent back through the network. Again, the network plugin thread will receive the results, provide them to the <code>NETWORK_LOCAL_JOB</code> task and mark that task as finished.</p>
<p>When all work is done, the plugin needs to be finalized. This will stop the plugin worker thread and close the sockets:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">mtapi_network_plugin_finalize(&amp;status);</code></pre></div>
<p>After that, the node may be finalized by calling <code>mtapi_finalize()</code>.</p>
<h4 id="opencl">OpenCL</h4>
<p>The MTAPI OpenCL plugin allows the user to leverage the computational power of an OpenCL accelerator, if one is available in the system.</p>
<p>Let us reuse the vector addition example from the network plugin. However, the action function is an OpenCL kernel now:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">const</span> <span class="dt">char</span> * kernel =
<span class="st">&quot;__kernel void AddVector(</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;  __global void* arguments,</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;  int arguments_size,</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;  __global void* result_buffer,</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;  int result_buffer_size,</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;  __global void* node_local_data,</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;  int node_local_data_size) {</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;  int ii = get_global_id(0);</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;  int elements = arguments_size / sizeof(float) / 2;</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;  if (ii &gt;= elements)&quot;</span>
<span class="st">&quot;    return;&quot;</span>
<span class="st">&quot;  __global float* a = (__global float*)arguments;</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;  __global float* b = ((__global float*)arguments) + elements;</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;  __global float* c = (__global float*)result_buffer;</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;  __global float* d = (__global float*)node_local_data;</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;  c[ii] = a[ii] + b[ii] + d[0];</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;}</span><span class="ch">\n</span><span class="st">&quot;</span>;</code></pre></div>
<p>The OpenCL plugin header file needs to be included first:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embb/mtapi/c/mtapi_opencl.h&gt;</span></code></pre></div>
<p>As with the network plugin, the OpenCL plugin needs to be initialized after the node has been initialized:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">mtapi_opencl_plugin_initialize(&amp;status);</code></pre></div>
<p>Then, the plugin action can be registered with the <code>OPENCL_JOB</code>:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">float</span> node_local = <span class="fl">1.0f</span>;
action = mtapi_opencl_action_create(
  OPENCL_JOB,
  kernel, <span class="st">&quot;AddVector&quot;</span>, <span class="dv">32</span>, <span class="dv">4</span>,
  &amp;node_local, <span class="kw">sizeof</span>(<span class="dt">float</span>),
  &amp;status);</code></pre></div>
<p>The kernel source and the name of the kernel to use (<code>AddVector</code>) need to be specified while creating the action. The kernel will be compiled using the OpenCL runtime and the provided node local data will be transferred to the accelerator memory. The local work size is the number of threads that will share OpenCL local memory, in this case 32. The element size tells the OpenCL plugin how many bytes a single element in the result buffer consumes, in this case 4, as a single result is a single float. The OpenCL plugin will launch <code>result_buffer_size/element_size</code> OpenCL threads to calculate the result.</p>
<p>Now, the <code>OPENCL_JOB</code> can be used like a normal MTAPI job to start tasks.</p>
<p>After all work is done, the plugin needs to be finalized. This will free all memory on the accelerator and delete the corresponding OpenCL context:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">mtapi_opencl_plugin_finalize(&amp;status);</code></pre></div>
<h4 id="cuda">CUDA</h4>
<p>Similar to the OpenCL plugin, the CUDA plugin can be used to start tasks on an Nvidia GPU.</p>
<p>The vector addition example looks slightly different in CUDA:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">extern</span> <span class="st">&quot;C&quot;</span> __global__ <span class="dt">void</span> AddVector(
  <span class="dt">void</span>* arguments,
  <span class="dt">int</span> arguments_size,
  <span class="dt">void</span>* result_buffer,
  <span class="dt">int</span> result_buffer_size,
  <span class="dt">void</span>* node_local_data,
  <span class="dt">int</span> node_local_data_size) {
  <span class="dt">int</span> ii = blockDim.x * blockIdx.x + threadIdx.x;
  <span class="dt">int</span> elements = arguments_size / <span class="kw">sizeof</span>(<span class="dt">float</span>) / <span class="dv">2</span>;
  <span class="kw">if</span> (ii &gt;= elements)
    <span class="kw">return</span>;
  <span class="dt">float</span>* a = (<span class="dt">float</span>*)arguments;
  <span class="dt">float</span>* b = ((<span class="dt">float</span>*)arguments) + elements;
  <span class="dt">float</span>* c = (<span class="dt">float</span>*)result_buffer;
  <span class="dt">float</span>* d = (<span class="dt">float</span>*)node_local_data;
  c[ii] = a[ii] + b[ii] + d[<span class="dv">0</span>];
}</code></pre></div>
<p>The kernel needs to be precompiled and will be transformed into a header file containing the resulting binary in a <code>char const *</code> array named <code>imageBytes</code>.</p>
<p>As with the OpenCL plugin, the CUDA plugin header file needs to be included first:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embb/mtapi/c/mtapi_cuda.h&gt;</span></code></pre></div>
<p>Then, the CUDA plugin needs to be initialized after the node has been initialized:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">mtapi_cuda_plugin_initialize(&amp;status);</code></pre></div>
<p>Now, the plugin action can be registered with the <code>CUDA_JOB</code>:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">float</span> node_local = <span class="fl">1.0f</span>;
action = mtapi_cuda_action_create(
  CUDA_JOB,
  <span class="kw">reinterpret_cast</span>&lt;<span class="dt">char</span> <span class="dt">const</span> *&gt;(imageBytes), <span class="st">&quot;AddVector&quot;</span>, <span class="dv">32</span>, <span class="dv">4</span>,
  &amp;node_local, <span class="kw">sizeof</span>(<span class="dt">float</span>),
  &amp;status);</code></pre></div>
<p>The precompiled kernel binary and the name of the kernel to use need to be specified while creating the action. The kernel and node local data provided are transferred to the accelerator memory. The local work size is the number of threads that will share CUDA local memory, in this case 32. The element size tells the CUDA plugin how many bytes a single element in the result buffer consumes, in this case 4, as a single result is a single float. The CUDA plugin will launch <code>result_buffer_size/element_size</code> CUDA threads to calculate the result.</p>
<p>Now, the <code>CUDA_JOB</code> can be used like a normal MTAPI job to start tasks.</p>
<p>After all work is done, the plugin needs to be finalized. This will free all memory on the accelerator and delete the corresponding CUDA context:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">mtapi_cuda_plugin_finalize(&amp;status);</code></pre></div>
<h2 id="heterogeneous-systems"><a name="cha_heterogeneous_systems"></a>Heterogeneous Systems</h2>
<h3 id="algorithms-1"><a name="sec_algorithms_heterogeneous_systems"></a>Algorithms</h3>
<p>All of the algorithms provided by EMB² can also be used on heterogeneous systems. This allows to transparently offload work on different kinds of compute units, thus leveraging the available hardware resources in an optimal way. In the following, we focus on the key concepts—for more detailed information, please see the source code contained in the <code>examples</code> directory.</p>
<p>In addition to functions, functors or lambdas, the algorithms accept MTAPI job handles that implement the intended functionality. The action functions will be given structures containing the arguments and results according to the signatures used above. For the sake of simplicity, CPU actions are used to simulate a heterogeneous system. The CPU actions are functions with the following signature:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> Action(
  <span class="dt">const</span> <span class="dt">void</span>* args,
  mtapi_size_t args_size,
  <span class="dt">void</span>* result_buffer,
  mtapi_size_t result_buffer_size,
  <span class="dt">const</span> <span class="dt">void</span>* node_local_data,
  mtapi_size_t node_local_data_size,
  mtapi_task_context_t* task_context
);</code></pre></div>
<p>A node handle is retrieved and used by the following examples like this:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">embb::mtapi::Node &amp; node = embb::mtapi::Node::GetInstance();</code></pre></div>
<h4 id="invoke">Invoke</h4>
<p>First, we consider <code>Invoke</code> to start two jobs in parallel. For that purpose, we define two action functions <code>InvokeA</code> and <code>InvokeB</code> that have no parameters and just increment a global value (<code>a</code> and <code>b</code>, respectively). For <code>InvokeA</code>, we have:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">static</span> <span class="dt">int</span> a = <span class="dv">0</span>;

<span class="dt">static</span> <span class="dt">void</span> InvokeA(
  <span class="dt">const</span> <span class="dt">void</span>* <span class="co">/*args*/</span>,
  mtapi_size_t <span class="co">/*args_size*/</span>,
  <span class="dt">void</span>* <span class="co">/*result_buffer*/</span>,
  mtapi_size_t <span class="co">/*result_buffer_size*/</span>,
  <span class="dt">const</span> <span class="dt">void</span>* <span class="co">/*node_local_data*/</span>,
  mtapi_size_t <span class="co">/*node_local_data_size*/</span>,
  mtapi_task_context_t* <span class="co">/*task_context*/</span>
) {
  a++;
}</code></pre></div>
<p>The actions are associated with the job IDs <code>JOB_A</code> and <code>JOB_B</code>. The job handles are retrieved as follows:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">static</span> <span class="dt">const</span> mtapi_job_id_t JOB_INVOKE_A = <span class="dv">10</span>;
embb::mtapi::Job job_a = node.GetJob(JOB_INVOKE_A);

<span class="dt">static</span> <span class="dt">const</span> mtapi_job_id_t JOB_INVOKE_B = <span class="dv">11</span>;
embb::mtapi::Job job_b = node.GetJob(JOB_INVOKE_B);</code></pre></div>
<p>After that, the jobs can be started:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">embb::algorithms::Invoke(job_a, job_b);</code></pre></div>
<p>The global variables <code>a</code> and <code>b</code> are now both set to <code>1</code>.</p>
<h4 id="sorting-1">Sorting</h4>
<p>To use <code>QuickSort</code>, we need a comparison function. <code>DescendingCompare</code> has two arguments of type <code>int</code> and one result of type <code>bool</code>. Since the function signature is fixed, we pack the arguments into a struct:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> <span class="kw">struct</span> {
  <span class="dt">int</span> lhs;
  <span class="dt">int</span> rhs;
} InT;</code></pre></div>
<p>The same holds for the result:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> <span class="kw">struct</span> {
  <span class="dt">bool</span> out;
} OutT;</code></pre></div>
<p><code>args</code> needs to be casted to <code>InT</code> and <code>result_buffer</code> to <code>OutT</code>:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">InT <span class="dt">const</span> * inputs = <span class="kw">static_cast</span>&lt;InT <span class="dt">const</span> *&gt;(args);
OutT * outputs = <span class="kw">static_cast</span>&lt;OutT *&gt;(result_buffer);</code></pre></div>
<p>Now, the arguments can be accessed, compared and the result can be written:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">outputs-&gt;out = inputs-&gt;lhs &gt; inputs-&gt;rhs;</code></pre></div>
<p><code>DescendingCompare</code> is associated with the job ID <code>JOB_COMPARE</code> and the job handle can be retrieved as follows:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">static</span> <span class="dt">const</span> mtapi_job_id_t JOB_COMPARE = <span class="dv">10</span>;
embb::mtapi::Job job_compare = node.GetJob(JOB_COMPARE);</code></pre></div>
<p>Then, we prepare a vector with <code>int</code>'s to be sorted:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">static</span> <span class="dt">const</span> size_t kCountSize = <span class="dv">10</span>;
std::vector&lt;<span class="dt">int</span>&gt; vector(kCountSize);
<span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; kCountSize; i++) {
  vector[i] = <span class="kw">static_cast</span>&lt;<span class="dt">int</span>&gt;(i + <span class="dv">2</span>);
}</code></pre></div>
<p>Finally, we call <code>QuickSort</code></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">embb::algorithms::QuickSort(vector.begin(), vector.end(), job_compare);</code></pre></div>
<p>and the <code>int</code>'s in the vector are now in descending order.</p>
<h4 id="counting-1">Counting</h4>
<p>The predicate supplied to <code>CountIf</code> can be implemented by an action function <code>CheckZero</code> that takes one argument of type <code>int</code> and returns one result of type <code>bool</code>. The argument is again packed into a struct:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> <span class="kw">struct</span> {
  <span class="dt">int</span> val;
} InT;</code></pre></div>
<p>The result struct is the same as in the sorting example. Also, <code>args</code> and <code>result_buffer</code> need to be casted to <code>InT</code> and <code>OutT</code>. Then, the body of <code>CheckZero</code> is simply:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">outputs-&gt;out = inputs-&gt;val == <span class="dv">0</span>;</code></pre></div>
<p>After retrieving the job handle</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">static</span> <span class="dt">const</span> mtapi_job_id_t JOB_CHECK_ZERO = <span class="dv">10</span>;
embb::mtapi::Job job_check_zero = node.GetJob(JOB_CHECK_ZERO);</code></pre></div>
<p>we prepare a vector with <code>int</code>'s to count (if they are zero):</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">static</span> <span class="dt">const</span> size_t kCountSize = <span class="dv">10</span>;
std::vector&lt;<span class="dt">int</span>&gt; vector(kCountSize);
<span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; kCountSize; i++) {
  vector[i] = <span class="dt">int</span>(i) % <span class="dv">2</span>;
}</code></pre></div>
<p>Finally, we call <code>CountIf</code></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::vector&lt;<span class="dt">int</span>&gt;::iterator::difference_type count =
  embb::algorithms::CountIf(vector.begin(), vector.end(), job_check_zero);</code></pre></div>
<p>which returns the number of zeros in the vector.</p>
<h4 id="foreach-loops-1">Foreach Loops</h4>
<p><code>ForEach</code> accepts functions taking a reference to an iterator as argument in order to work on the referenced object. Consider, for example, an action function <code>Double</code> that doubles a given value. It has one argument of type <code>int</code> and one result of type <code>int</code>. The argument struct is thus the same as in the counting example. The result resides in a struct containing one <code>int</code>:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> <span class="kw">struct</span> {
  <span class="dt">int</span> out;
} OutT;</code></pre></div>
<p><code>args</code> and <code>result_buffer</code> need to be casted to <code>InT</code> and <code>OutT</code> once more. The body of <code>Double</code> is defined as follows:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">outputs-&gt;out = inputs-&gt;val * <span class="dv">2</span>;</code></pre></div>
<p>After retrieving the job handle</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">static</span> <span class="dt">const</span> mtapi_job_id_t JOB_DOUBLE = <span class="dv">10</span>;
embb::mtapi::Job job_double = node.GetJob(JOB_DOUBLE);</code></pre></div>
<p>we can call <code>ForEach</code> with this handle:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">embb::algorithms::ForEach(vector.begin(), vector.end(), job_double);</code></pre></div>
<h4 id="reductions-and-prefix-computations">Reductions and Prefix Computations</h4>
<p><code>Reduce</code> and <code>Scan</code> use a reduction and a transformation function. The reduction function has two arguments and one result that all have the same type. The transformation function has one argument and one result with potentially different types. In our example, they are all of type <code>int</code>. For simplicity, we reuse the <code>Double</code> action and <code>JOB_DOUBLE</code> from the previous example as our transformation function. For the reduction function, we introduce an action <code>Add</code> with the following simple body:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">outputs-&gt;out = inputs-&gt;lhs + inputs-&gt;rhs;</code></pre></div>
<p>The job handles are retrieved as follows:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">static</span> <span class="dt">const</span> mtapi_job_id_t JOB_DOUBLE = <span class="dv">10</span>;
embb::mtapi::Job job_double = node.GetJob(JOB_DOUBLE);

<span class="dt">static</span> <span class="dt">const</span> mtapi_job_id_t JOB_ADD = <span class="dv">11</span>;
embb::mtapi::Job job_add = node.GetJob(JOB_ADD);</code></pre></div>
<p>Next, we create a vector of <code>int</code>'s:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">static</span> <span class="dt">const</span> size_t kCountSize = <span class="dv">10</span>;
std::vector&lt;<span class="dt">int</span>&gt; vector(kCountSize);
<span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; kCountSize; i++) {
  vector[i] = <span class="dt">int</span>(i);
}</code></pre></div>
<p>The elements of the vector can then be reduced by:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> result =
  embb::algorithms::Reduce(vector.begin(), vector.end(), <span class="dv">0</span>,
    job_add, job_double);</code></pre></div>
<p>The prefix sum is computed similarly:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::vector&lt;<span class="dt">int</span>&gt; output(kCountSize);
embb::algorithms::Scan(vector.begin(), vector.end(), output.begin(), <span class="dv">0</span>,
  job_add, job_double);</code></pre></div>
<h3 id="dataflow-1"><a name="sec_dataflow_heterogeneous_systems"></a>Dataflow</h3>
<p>Dataflow networks can be used on heterogeneous systems as well. In addition to functions and functors, dataflow sources, sinks, and processes accept MTAPI job handles implementing the intended functionality. The action functions will be given structures containing the arguments and results according to the signatures used previously. To simulate a heterogeneous system, CPU actions with the following signature are used:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> Action(
  <span class="dt">const</span> <span class="dt">void</span>* args,
  mtapi_size_t args_size,
  <span class="dt">void</span>* result_buffer,
  mtapi_size_t result_buffer_size,
  <span class="dt">const</span> <span class="dt">void</span>* node_local_data,
  mtapi_size_t node_local_data_size,
  mtapi_task_context_t* task_context
);</code></pre></div>
<p>Suppose, for example, we want to double the integers from 0 to 9 and sum them up. For that purpose, we define three action functions, one for a source called <code>Generate</code>, one for a process called <code>Double</code>, and one for a sink called <code>Accumulate</code>. Each of them is associated with a different job.</p>
<h4 id="generate">Generate</h4>
<p>The source function generates integers from 0 to 9. It receives no arguments and returns a <code>bool</code> that indicates whether generating integers shall continue, and an <code>int</code> that represents the generated value. The results are packed into a struct:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> <span class="kw">struct</span> {
  <span class="dt">bool</span> more;
  <span class="dt">int</span> out;
} OutT;</code></pre></div>
<p>The <code>result_buffer</code> pointer needs to be casted to <code>OutT</code>:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">OutT * outputs = <span class="kw">static_cast</span>&lt;OutT *&gt;(result_buffer);</code></pre></div>
<p>Then, the body of the function is:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">static</span> <span class="dt">int</span> value = <span class="dv">0</span>;
outputs-&gt;out = value;
outputs-&gt;more = value &lt; <span class="dv">10</span>;
value++;</code></pre></div>
<h4 id="double">Double</h4>
<p>The process function expects and <code>int</code> and returns the double of its value. Both, the argument and the result are packed into a struct:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> <span class="kw">struct</span> {
  <span class="dt">int</span> val;
} InT;</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> <span class="kw">struct</span> {
  <span class="dt">int</span> out;
} OutT;</code></pre></div>
<p>As usual, <code>args</code> as well as <code>result_buffer</code> need to be casted:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">InT <span class="dt">const</span> * inputs = <span class="kw">static_cast</span>&lt;InT <span class="dt">const</span> *&gt;(args);</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">OutT * outputs = <span class="kw">static_cast</span>&lt;OutT *&gt;(result_buffer);</code></pre></div>
<p>Finally, the actual calculation is simply:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">outputs-&gt;out = inputs-&gt;val * <span class="dv">2</span>;</code></pre></div>
<h4 id="accumulate">Accumulate</h4>
<p>The sink is supposed to add up all incoming values. It returns no result and expects a value of type <code>int</code> which is packed into a struct:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> <span class="kw">struct</span> {
  <span class="dt">int</span> val;
} InT;</code></pre></div>
<p>After casting <code>args</code> to <code>InT</code>, the inputs can be accumulated:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">InT <span class="dt">const</span> * inputs = <span class="kw">static_cast</span>&lt;InT <span class="dt">const</span> *&gt;(args);</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">accumulated_result += inputs-&gt;val;</code></pre></div>
<h4 id="network-1">Network</h4>
<p>In the main function, we first retrieve the node handle:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">embb::mtapi::Node &amp; node = embb::mtapi::Node::GetInstance();</code></pre></div>
<p>Then, we obtain the job handles:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">static</span> <span class="dt">const</span> mtapi_job_id_t JOB_GENERATE = <span class="dv">10</span>;
embb::mtapi::Job job_generate = node.GetJob(JOB_GENERATE);

<span class="dt">static</span> <span class="dt">const</span> mtapi_job_id_t JOB_DOUBLE = <span class="dv">11</span>;
embb::mtapi::Job job_double = node.GetJob(JOB_DOUBLE);

<span class="dt">static</span> <span class="dt">const</span> mtapi_job_id_t JOB_ACCUMULATE = <span class="dv">12</span>;
embb::mtapi::Job job_accumulate = node.GetJob(JOB_ACCUMULATE);</code></pre></div>
<p>After that, we define the network and its processes:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> embb::dataflow::Network Net;
Net net(<span class="dv">4</span>);

Net::Source&lt;<span class="dt">int</span>&gt; source(net, job_generate);

Net::ParallelProcess&lt;Net::Inputs&lt;<span class="dt">int</span>&gt;, Net::Outputs&lt;<span class="dt">int</span>&gt; &gt;
  filter(net, job_double);

Net::Sink&lt;<span class="dt">int</span>&gt; sink(net, job_accumulate);</code></pre></div>
<p>Finally, we connect the processes and run the network:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">source &gt;&gt; filter &gt;&gt; sink;</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">net();</code></pre></div>
<h2 id="tutorial-application"><a name="cha_tutorial_application"></a>Tutorial Application</h2>
<p>In the following, we create a video processing application that applies the concepts described in the previous sections to a more complex problem. The application is supposed to read a video file, apply some filters, and write the resulting output video to a file. For handling video files, we are going to use <a href="https://ffmpeg.org/">FFmpeg</a>. Details on how to build and run the application can be found in the <code>README.md</code> file in <code>doc/tutorial/application</code>.</p>
<p>The application consists of five parts, the main program, the filters, the input video handler, the frame format converter, and the output video builder. Three of them relate to FFmpeg video decoding and encoding. The input video handler opens a given video file and is used to read consecutive frames from the stream until there are no more frames. The frame format converter is used to convert from the source color format to RGB and vice versa, since the filtering is done in RGB color space. The output video builder encodes the resulting image stream and writes it back to a video file. For the sake of brevity, we will not cover these three parts in detail but focus on parallelizing the filters as well as the whole pipeline. The filters come in three flavors: sequential, parallel using the algorithms library, and as OpenCL kernels. The main application connects the pipeline stages into a working whole.</p>
<h3 id="filters">Filters</h3>
<p>The filters are essentially loops iterating over the pixels and applying some operation to them. Here is a simple color to greyscale filter:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> applyBlackAndWhite(AVFrame* frame) {
  av_frame_make_writable(frame);

  <span class="dt">int</span> <span class="dt">const</span> width = frame-&gt;width;
  <span class="dt">int</span> <span class="dt">const</span> height = frame-&gt;height;

  <span class="kw">for</span> (<span class="dt">int</span> y = <span class="dv">0</span>; y &lt; height; y++) {
    <span class="kw">for</span> (<span class="dt">int</span> x = <span class="dv">0</span>; x &lt; width; x++) {
      <span class="dt">int</span> p = mapToData(x, y, width);
      <span class="dt">int</span> r = frame-&gt;data[<span class="dv">0</span>][p];
      <span class="dt">int</span> g = frame-&gt;data[<span class="dv">0</span>][p + <span class="dv">1</span>];
      <span class="dt">int</span> b = frame-&gt;data[<span class="dv">0</span>][p + <span class="dv">2</span>];
      <span class="dt">int</span> mean = (r + g + b) / <span class="dv">3</span>;
      frame-&gt;data[<span class="dv">0</span>][p] = mean;
      frame-&gt;data[<span class="dv">0</span>][p + <span class="dv">1</span>] = mean;
      frame-&gt;data[<span class="dv">0</span>][p + <span class="dv">2</span>] = mean;
    }
  }
}</code></pre></div>
<p>The other filters contained in <code>doc\tutorial\application\src\filters.cc</code> work similarly—feel free to experiment with them. By default, the application &quot;cartoonifies&quot; the incoming video stream (see function <code>filter</code> in <code>main.cc</code>).</p>
<p>Parallelizing the above filter is straightforward using the algorithms building block: We replace the loops by a single call to <code>ForLoop</code> and compute the <code>x</code> and <code>y</code> pixel coordinates from the given index:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> applyBlackAndWhiteParallel(AVFrame* frame) {
  av_frame_make_writable(frame);

  <span class="dt">int</span> <span class="dt">const</span> width = frame-&gt;width;
  <span class="dt">int</span> <span class="dt">const</span> height = frame-&gt;height;

  embb::algorithms::ForLoop(<span class="dv">0</span>, width*height, [&amp;](<span class="dt">int</span> idx) {
    <span class="dt">int</span> x = idx % width;
    <span class="dt">int</span> y = idx / width;
    <span class="dt">int</span> p = mapToData(x, y, width);
    <span class="dt">int</span> r = frame-&gt;data[<span class="dv">0</span>][p];
    <span class="dt">int</span> g = frame-&gt;data[<span class="dv">0</span>][p + <span class="dv">1</span>];
    <span class="dt">int</span> b = frame-&gt;data[<span class="dv">0</span>][p + <span class="dv">2</span>];
    <span class="dt">int</span> mean = (r + g + b) / <span class="dv">3</span>;
    frame-&gt;data[<span class="dv">0</span>][p] = mean;
    frame-&gt;data[<span class="dv">0</span>][p + <span class="dv">1</span>] = mean;
    frame-&gt;data[<span class="dv">0</span>][p + <span class="dv">2</span>] = mean;
  });
}</code></pre></div>
<p>Now, the filter runs in parallel but the control flow of the whole application is still sequential which limits scalability.</p>
<h3 id="control-flow">Control Flow</h3>
<p>Applying video decoding, format conversion, filtering, another format conversion, and video encoding to a sequence of frames can be implemented using the following loop:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">while</span> (readFromFile(frame)) {
  convertToRGB(frame, convertedFrame);
  filter(convertedFrame);
  convertToOriginal(convertedFrame, originalFrame);
  writeToFile(originalFrame);
}</code></pre></div>
<p>The steps executed in the loop body can be seen as a pipeline which allows us to parallelize them using dataflow networks. Each of the operations is wrapped into a source, a (parallel) process, or a sink. The resulting objects are then connected to a network:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Network nw(<span class="dv">8</span>);

Network::Source&lt;AVFrame*&gt; read(nw, embb::base::MakeFunction(readFromFile));

Network::ParallelProcess&lt;Network::Inputs&lt;AVFrame*&gt;,
  Network::Outputs&lt;AVFrame*&gt; &gt;
    rgb(nw, embb::base::MakeFunction(convertToRGB));

Network::ParallelProcess&lt;Network::Inputs&lt;AVFrame*&gt;,
  Network::Outputs&lt;AVFrame*&gt; &gt;
    original(nw, embb::base::MakeFunction(convertToOriginal));

Network::ParallelProcess&lt;Network::Inputs&lt;AVFrame*&gt;,
  Network::Outputs&lt;AVFrame*&gt; &gt;
    filter(nw, embb::base::MakeFunction(applyFilter));

Network::Sink&lt;AVFrame*&gt; write(nw, embb::base::MakeFunction(writeToFile));

read &gt;&gt; rgb &gt;&gt; filter &gt;&gt; original &gt;&gt; write;

nw();</code></pre></div>
<p>This way, scalability is significantly improved, as all parts now run in parallel.</p>
<h4 id="heterogeneous-systems-1">Heterogeneous Systems</h4>
<p>As discussed in the chapter on <a href="#cha_heterogeneous_systems">heterogeneous systems</a>, some systems feature additional accelerators, e.g. a GPU, to further improve processing speed. Using OpenCL (or CUDA), we can leverage the power of such accelerators to speed up the filters. Let us consider the following OpenCL implementation:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">char</span> <span class="dt">const</span> * mean_kernel =
<span class="st">&quot;__kernel void mean(</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;  __global void* arguments,</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;  int arguments_size,</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;  __global void* result_buffer,</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;  int result_buffer_size,</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;  __global void* node_local_data,</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;  int node_local_data_size) {</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;  int idx = get_global_id(0);</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;  int elements = (arguments_size - sizeof(int) * 3) / 3;</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;  if (idx &gt;= elements)</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;    return;</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;  __global int * param = (__global int*)arguments;</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;  __global unsigned char * in_buffer =&quot;</span>
<span class="st">&quot;    ((__global unsigned char*)arguments) + sizeof(int) * 3;</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;  __global unsigned char * out_buffer =&quot;</span>
<span class="st">&quot;    (__global unsigned char*)result_buffer;</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;  int width = param[0];</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;  int height = param[1];</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;  int size = param[2];</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;  int size_lt = (size % 2 != 0) ? size / 2 : size / 2 - 1;</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;  int const size_rb = size / 2;</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;  int x = idx % width;</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;  int y = idx / width; </span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;  int close = 0;</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;  int p = (x + y * width) * 3;</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;  int r = 0;</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;  int g = 0;</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;  int b = 0;</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;  for (int k1 = y - size_lt; k1 &lt;= y + size_rb; k1++) {</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;    for (int k2 = x - size_lt; k2 &lt;= x + size_rb; k2++) {</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;      if (k1 &gt;= 0 &amp;&amp; k1 &lt; height &amp;&amp; k2 &gt;= 0 &amp;&amp; k2 &lt; width) {</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;        close++;</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;        int p2 = (k2 + k1 * width) * 3;</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;        r += in_buffer[p2];</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;        g += in_buffer[p2 + 1];</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;        b += in_buffer[p2 + 2];</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;      }</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;    }</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;  }</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;  out_buffer[p] = r / close;</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;  out_buffer[p + 1] = g / close;</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;  out_buffer[p + 2] = b / close;</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="st">&quot;}</span><span class="ch">\n</span><span class="st">&quot;</span>;</code></pre></div>
<p>First, this kernel needs to be wrapped into an MTAPI action:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">mtapi_opencl_action_create(JOB_MEAN, filters::mean_kernel,
  <span class="st">&quot;mean&quot;</span>, <span class="dv">32</span>, <span class="dv">3</span>, &amp;node_local, <span class="kw">sizeof</span>(<span class="dt">int</span>), &amp;status);
<span class="kw">if</span> (status != MTAPI_SUCCESS) {
  std::cout &lt;&lt; <span class="st">&quot;Could not create OpenCL action...&quot;</span> &lt;&lt; std::endl;
  mtapi_opencl_plugin_finalize(MTAPI_NULL);
  embb::mtapi::Node::Finalize();
  <span class="kw">return</span>;
}</code></pre></div>
<p>Then, the filter can be used like any job. Note, however, the additional cost for copying the frame and the parameters of the filter into a single buffer:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">args = <span class="kw">new</span> <span class="dt">unsigned</span> <span class="dt">char</span>[n_bytes + <span class="kw">sizeof</span>(<span class="dt">int</span>) * <span class="dv">4</span>];
res = <span class="kw">new</span> <span class="dt">unsigned</span> <span class="dt">char</span>[n_bytes + <span class="kw">sizeof</span>(<span class="dt">int</span>) * <span class="dv">4</span>];

size = n_bytes + <span class="kw">sizeof</span>(<span class="dt">int</span>) * <span class="dv">3</span>;
param = <span class="kw">reinterpret_cast</span>&lt;<span class="dt">int</span>*&gt;(args);
data = args + <span class="kw">sizeof</span>(<span class="dt">int</span>) * <span class="dv">3</span>;
param[<span class="dv">0</span>] = width;
param[<span class="dv">1</span>] = height;
param[<span class="dv">2</span>] = <span class="dv">3</span>;
memcpy(data, frame-&gt;data[<span class="dv">0</span>], n_bytes);
job = node.GetJob(JOB_MEAN);
task = node.Start(MTAPI_TASK_ID_NONE, job.GetInternal(), args, size,
  res + <span class="kw">sizeof</span>(<span class="dt">int</span>)*<span class="dv">4</span>, n_bytes, MTAPI_DEFAULT_TASK_ATTRIBUTES);
task.Wait();</code></pre></div>
<p>When wrapped into a dataflow process, it can even be used as a part of the pipeline outlined before:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Network::ParallelProcess&lt;Network::Inputs&lt;AVFrame*&gt;,
  Network::Outputs&lt;AVFrame*&gt; &gt;
  filter(nw, embb::base::MakeFunction(applyFilterOpenCL));</code></pre></div>
<h2 id="bibliography"><a name="cha_bibliography"></a>Bibliography</h2>
<p><a name="bib_mtapi"></a>[1] Multicore Task Management API (MTAPI) Specification V1.0, The Multicore Association, March 2013.</p>
</body>
</html>
